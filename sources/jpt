#!/usr/bin/env bash
#!/usr/bin/env zsh
#choose your shell with the first line, works in both

#############
# FUNCTIONS #
#############

function jpt()( #v1.0.4 jpt([options] [query] [fileArg])
{ set +x; } &> /dev/null
: <<-LICENSE_BLOCK
jpt - JSON Power Tool (https://github.com/brunerd/jpt)
Copyright (c) 2020 Joel Bruner (https://github.com/brunerd)
Other portions: Copyright (c) 2007 Stefan Goessner (goessner.net), Copyright (c) 2020 "jpaquit" (https://github.com/jpaquit), Copyright (c) 2016 Kris Nye, Copyright (c) 2012 Dharmafly, Copyright (c) Kyle Simpson
Licensed under the MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
LICENSE_BLOCK

#our Javascript as a shell variable
read -r -d '' JSCode <<-'EOT'
//*********//
//FUNCTIONS//
//*********//

//brunerd JSONPath 0.9.17 (slim normalize)- XPath for JSON
//see https://github.com/brunerd/jsonpath for complete function
function jsonPath(obj, expr, arg) {
	var P = {
		resultType: arg && arg.resultType || "VALUE",
		singleQuoteKeys: arg && arg.singleQuoteKeys || false,
		escapeUnicode: arg && arg.escapeUnicode || false,
		result: [],
		normalize: function(expr) {
			if (expr.constructor === null || expr.constructor !== String) { return expr }
			//objectifyExpressions ensures strings are already parsed into objects
			//** SNIP **			
		},
		asPath: function(path) {
			if(P.resultType === "PATH_OBJECT"){ return {"path":path} }

			var qt = P.singleQuoteKeys ? "'" : '"';
			var p=(P.resultType === "PATH_JSONPOINTER" ? "" : "$");
			var x = path.slice()

			for (var i=0,n=x.length; i<n; i++){

				if(P.resultType === "PATH_JSONPOINTER") {
					p += "/" + (x[i].constructor === Number ? x[i] : x[i].replace(/~/g,"~0").replace(/\//g,"~1"))
				}
				else {
					p += x[i].constructor === Number ? "["+x[i]+"]" : (P.resultType === "PATH_DOTTED" && /^[A-Za-z_$][\w\d$]*$/.test(x[i]) ? "." + x[i] : ("["+ qt + x[i].replace((P.escapeUnicode ? /[\u0000-\u001f\u007f-\uffff|\\|"|']/g : /[\u0000-\u001f\u007f|\\|"|']/g), function(chr) { switch(chr) { case '\b': return "\\b"; case '\f': return "\\f"; case '\n': return "\\n"; case '\r': return "\\r"; case '\t': return "\\t";case '\\': return "\\\\";case '"': return (P.singleQuoteKeys ? "\"" : "\\\"" );case '\'': return (P.singleQuoteKeys ? "\\'" : "'" );default: return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4);}}) + qt + "]"));
				}
			}
			return p;
		},
		store: function(p, v) {
			if (P.escapeUnicode && v !== null && v.constructor === String){
				v = v.replace(/[\u007F-\uFFFF]/g, function(chr) { return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4) })
			}

			if (p) { P.result[P.result.length] = /^PATH/.test(P.resultType) ? P.asPath(p) : v }
			return !!p;
		},
		trace: function(expr, val, path) {
			if(expr === false) return expr

			if (expr.length) {
				
				var x = expr.slice()
				var loc = x.shift();

				
				if(val !== null && Array.isArray(val) && loc.constructor === String && loc.match(/^0/) && loc !== "0"){
					throw new Error("Property name '"+ loc +"' is a string with leading zeros and target is an array!")
				}
				
				if(loc.constructor === Number && Math.sign(loc) === -1 && (val instanceof Array || val.constructor === String)) { 
					loc = (val.length+loc) 
				}

				if(Array.isArray(loc)){
					for (i=0; i<loc.length; i++) {
						var tx = x.slice()
						tx.unshift(loc[i])
						P.trace(tx, val, path)
					}
				}
				else if(loc.constructor === Object) {
					if(Array.isArray(loc.expression)){
						P.slice(loc.expression, x, val, path);
					}
					else if (loc.expression === "*") {
						P.walk(loc.expression, x, val, path, function(m,l,x,v,p) { var tx = x.slice(); tx.unshift(m); P.trace(tx,v,p); });
					}
					else if (loc.expression === "..") {
						P.trace(x, val, path);
						P.walk(loc, x, val, path, function(m,l,x,v,p) { var tx = x.slice(); tx.unshift({"expression":".."}); var tp = p.slice(); tp.push(m); typeof v[m] === "object" && P.trace(tx,v[m],tp); });
					}
					else if (/^\(.*?\)$/.test(loc.expression))
					{
						var tx = x.slice();
						tx.unshift(P.eval(loc.expression, val, path[path.length-1]))
						P.trace(tx, val, path);
					}
					else if (/^-$/.test(loc.expression))
					{
						if(val !== null && Array.isArray(val)) {
							var tx = x.slice();
							tx.unshift(P.eval("(@.length)", val, path[path.length-1]))
							P.trace(tx, val, path);
						}
					}
					else if (/^\?\(.*?\)$/.test(loc.expression)){
						P.walk(loc.expression, x, val, path, function(m,l,x,v,p) {
							if (P.eval(l.replace(/^\?\((.*?)\)$/,"$1"), v instanceof Array ? v[m] : v, m)) {
								var tx = x.slice(); tx.unshift(m); P.trace(tx,v,p);
							} 
						});
					}
				}
				else if (val && val.constructor !== String && val[loc] !== undefined) {
					var tpath = path.slice()
					tpath.push(Array.isArray(val) ? Number(loc) : loc)
					P.trace(x, val[loc], tpath);
				}
			}
			else {
				P.store(path, val);
			}
		},
		walk: function(loc, expr, val, path, f) {
			if (val instanceof Array) {
				for (var i=0,n=val.length; i<n; i++) {
					if (i in val) {
						f(i,loc,expr,val,path);
					}
				}
			}
			else if (typeof val === "object") {
				for (var m in val) {
					if (val.hasOwnProperty(m)) {
 						f(m,loc,expr,val,path);
					}
				}
			}
		},
		slice: function(loc, expr, val, path) {
			if (val instanceof Array) {
				var str="", len, start, end, step=1;
				loc[0]=loc[0] !== undefined ? loc[0] : null; loc[1]=loc[1] !== undefined ? loc[1] : null; loc[2]=loc[2] !== undefined ? loc[2] : null

				if ((loc[2] === null || loc[2].constructor === Number ? loc[2] : P.eval(loc[2].expression,val,path[path.length-1])) === 0) { 
					throw new RangeError("Slice step cannot be zero: [" + loc.join(":") + "]") 
				}
				else { 
					step=parseInt((loc[2] === null || loc[2].constructor === Number ? loc[2] : P.eval(loc[2].expression,val,path[path.length-1]))||step)
				}

				if(Math.sign(step) === -1){
					len=val.length, start=len-1, end=(len+(loc[1] === null ? 1 : 0))*(-1)
				}
				else {
					len=val.length, start=0, end=len
				}

				start = parseInt((loc[0] === null || loc[0].constructor === Number ? loc[0] : P.eval(loc[0].expression,val,path[path.length-1]))||((loc[0] === null || loc[0].constructor === Number ? loc[0] : P.eval(loc[0].expression,val,path[path.length-1])) === 0 ? 0 : start));
				end = (loc[1] === 0) ? 0 : parseInt((loc[1] === null || loc[1].constructor === Number ? loc[1] : P.eval(loc[1].expression,val,path[path.length-1]))||end)

				start = (start < 0) ? Math.max(Math.sign(step) === -1 ? -1 : 0,start+len) : Math.min(len,start);
				end = (end < 0) ? Math.max(Math.sign(step) === -1 ? -1 : 0,end+len) : Math.min(len,end);

				if(Math.sign(step) === -1){ var op=">" } else { var op="<" }

				for (var i=start; eval(i+op+end); i+=step){
					var texpr = expr.slice()
					texpr.unshift(i)
					P.trace(texpr, val, path);
				}
    		}
		},
		eval: function(x, _v, _vname) {

			var tx = x.slice()

			if ((/^\(.*?\)$/).test(x)) { tx = tx.replace((/^\((.*?)\)$/),"$1") }

			var forbiddenInvocations=tx.split('').reverse().join('')
				.replace(/(["'])(.*?)\1(?!\\)/g, "")
				.replace(/(\/.*?\/(?!\\)\s*~=)|(=~*\s\/.*?\/(?!\\))/g, "")
				.replace(/\(\s*/g,"(").replace(/([;\.\+\-~\!\*\/\%\>\<\&\^\|\:\?\,])/g, " ")
				.replace(/\s+/g," ")
				.split('').reverse().join('').split(' ')
				.filter(function(f){return (/\(/).test(f)})
				.filter(function(f){return (/[!^]\(|[\w\d_$]\(/).test(f)})
				.filter(function(f){return !((/test\(|exec\(|match\(/).test(f))})

			if(forbiddenInvocations.length){ throw new Error("Invocation violation: " + forbiddenInvocations) };

			try {
				var evalResult = eval(x.replace(/(^|[^\\])@/g, "$1_v")
					.replace(/\\@/g, "@")
					.replace(/(_v(?:(?!(\|\||&&)).)*)=~((?:(?!\)* *(\|\||&&)).)*)/g, 
						function(match, p1, p2, p3, offset, currentString) {
							return match ? p3.trim()+'.test('+p1.trim()+')' : match
						}
					)
					.replace(/((?:(?!\)* *(\|\||&&)).)*)\s+=~\s+(_v(?:(?!(\|\||&&)).)*)/g, 
						function(match, p1, p2, p3, offset, currentString) {
							return match ? p1.trim()+'.test('+p3.trim()+')' : match
						}
					)
				);
				return evalResult
			}
			catch(e) { 
				//throw new SyntaxError("eval: " + e.message) 

				throw new SyntaxError("eval: " + e.message + ": " + x.replace(/(^|[^\\])@/g, "$1_v")
					.replace(/\\@/g, "@") // issue 7 : resolved
					// 2020/01/09 - manage regexp syntax "=~"
					.replace(/(_v(?:(?!(\|\||&&)).)*)=~((?:(?!\)* *(\|\||&&)).)*)/g, 
						function(match, p1, p2, p3, offset, currentString) { 
							return match ? p3.trim()+'.test('+p1.trim()+')' : match
						}
					) 
					.replace(/((?:(?!\)* *(\|\||&&)).)*)\s+=~\s+(_v(?:(?!(\|\||&&)).)*)/g, 
						function(match, p1, p2, p3, offset, currentString) { 
							return match ? p3.trim()+'.test('+p1.trim()+')' : match
						}
					)
				)
			}
		}
	};

	var $ = obj;

	if (expr && obj !== undefined && (P.resultType == "VALUE" || /^PATH/.test(P.resultType))) {
		P.trace(P.normalize(expr), obj, []);

		return P.result.length ? P.result : [];
	}
}

//workaround for jsc print() limit of 0x2AAAAAAA (dec: 715827882) ~682.6 MiB
function jscChunkPrint(resultText) {
	var breakIndex,windowEnd,startBytes=0;
	var totalBytes=resultText.length;
	var delimiters=[ '\n', '","' , '",' , ',"' , '},{' ,'":"' , '":{' ]
	do {
		if ((startBytes + maxSize.print) > totalBytes) { windowEnd=totalBytes } 
		else { 
			for(var i=0;i<=delimiters.length-1;i++){
				breakIndex=resultText.lastIndexOf(delimiters[i],startBytes + maxSize.print)
				if (breakIndex !== -1 && breakIndex > startBytes ) { windowEnd=breakIndex + delimiters[i].length - 1; break;} 
			}
			//if no good index just print it out regardless of break (newlines can always be removed without consequence in actual JSON)
			if (breakIndex < startBytes) {windowEnd=startBytes + maxSize.print}
		}
		print(resultText.slice(startBytes,windowEnd))
		if (windowEnd === totalBytes) { break; }
		if (resultText.charAt(windowEnd) === '\n') { startBytes=windowEnd+1 } else { startBytes=windowEnd }
	} while (windowEnd < totalBytes)
}

//render JSON into alternate textual forms
//mutated from: https://davidwells.io/snippets/traverse-object-unknown-size-javascript
function renderObject(obj,pathName,option,level) {
	option = option || {}
	option.maxDepth = (option.maxDepth === undefined || option.maxDepth < -1 ) ? -1 : option.maxDepth

	var keyQuotes = (option.q ? "'" : '"')
	var stringQuotes = (option.Q ? "'" : '"')
	var result = []
	var indent = ''

	//indents the line based on the -i value plus the level we are at
 	const makeIndent = function(spaceArg,level) {
		var indentComp = '';
		//create the string component for each indent level
		if (spaceArg.constructor === Number)  { for(var i=0;i<spaceArg;i++){ indentComp+=" " } }
		else { indentComp=spaceArg }
		//create the final indent string
		for(var i=0;i < level; i++) { indent+=indentComp }		
		return indent;
 	}

	//keep track of our depth level
	if (isNaN(level)) {var level=0} else {level++}
	//-K key name is only for -R and -J  output
	if(option.K && !(option.J || option.R)) {option.K=false}

	//create indent if -T or -K is specified
	if ((option.K || option.T) && option.i ) { var indent = makeIndent(option.spaceArg,level) }

	//NULL
	//turn null into a string and set variable to denote this
	//we must still do it this way because ?. optional chaining is not available 10.4-10.14 only 10.15+
	if ( obj === null ) { var isNull=true; obj=((option.n || pathName) ? "null" : "") }

	//used for -C constructor output
	var typeString = (obj.constructor === Number) ? ": Number" : (obj.constructor === String && !isNull) ? ": String" : (obj.constructor === Array) ? ": Array" : (obj.constructor === Object) ? ": Object" : (obj.constructor === Boolean) ? ": Boolean" : ": null"

	//ARRAY
	if (obj.constructor === Array) {
		if ((option.J || (option.R)) && !option.P && (pathName || pathName === "")) { 
			result.push(indent + pathName + (option.C ? ": Array" : '' )) 
		}
		//-L "initialize" the array if we are outputting pathname but we are not -R
		else if(!option.P && (pathName || pathName === "")) { 
			result.push( indent + pathName + (option.K ? (!option.C ? '' : typeString ) : level === option.maxDepth ? '=' + JSON.stringify(obj,null,0) : '=[]' )) 
		}

		if(option.maxDepth === -1 || level < option.maxDepth) {
			//iterate through each sending the object and the i to the function
			obj.forEach(function(obj, i) {
				//send on the path name or null
				result.push(renderObject(obj,(pathName || pathName === "" ? (option.K ? i.toString() : (pathName + (option.R ? "/" + i : "[" + i + "]"))) : null ),option,level))
			})
		}
	}
	//OBJECT
	else if (obj.constructor === Object) {
		if ((option.J || option.R) && !option.P && (pathName || pathName === "")) {
			result.push(indent + pathName + (option.C ? ": Object" : '' ))
		}
		//if -L initialize the object
		else if((pathName || pathName === "") && !option.P){
			result.push(indent + pathName + (option.K ? (!option.C ? '' : typeString ) : level === option.maxDepth ? '=' + JSON.stringify(obj,null,0) : '={}' ))
		}

		if(option.maxDepth === -1 || level < option.maxDepth) {
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {				
					//-R -J and -L (optionally with -P -K)
					if(pathName || pathName === ""){
						//escape the whitespaces and control characters in the key name						
						//replaces: " \ \b \f \n \r \t and 7f-ffff
						//-R JSON Pointer path
						if (option.R) {
							//if -K only the current key is displayed
							var thisPath= (option.K ? "" : pathName + "/") + key.replace(/~/g,"~0").replace(/\//g,"~1")
						}
						//-J or -L with -d for dot notation (if it meets requirements)
						else if(option.d && !option.K && (/^[A-Za-z_$][$\w\d]*$/).test(key)){
							var thisPath=(option.K ? '' : pathName + ".") + key
						}
						//-J JSONPath, -L  Literals, or -K Key only with encoding options
						else {
							// \u encode 7F and above (in addition to 0-1f)
							if (option.u){
								var keyEncodeRegex=/[\u0000-\u001f\u007f-\uffff|\\|"|']/g
							} 
							//control and whitespace always get encoded with -J or -K
							else {
								var keyEncodeRegex=/[\u0000-\u001f\u007f|\\|"|']/g
							}
							var keyEsc=key.replace(keyEncodeRegex, function(chr) { switch(chr) { case ' ': return " "; case '\b': return "\\b"; case '\f': return "\\f"; case '\n': return "\\n"; case '\r': return "\\r"; case '\t': return "\\t"; case '\\': return "\\\\"; case "\"": return (keyQuotes === "'" ? "\"" : "\\\"" ); case '\'': return (keyQuotes === "'" ? "\\'" : "'" ); default: return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4);}});
							if(option.K && ! option.L) {
								//raw output
								//-k unquoted (but escape whitespace as if it is, either double or single with -Q/-q)
								if(option.k){
									var thisPath=keyEsc
								}
								//quoted
								else {
									var thisPath=keyQuotes + keyEsc + keyQuotes
								}
							} 
							//-J or -L
							else {
								//brackets and quotes per -Q/-q
								var thisPath=(pathName + "[" + keyQuotes + keyEsc + keyQuotes + "]") 														
							}
						}
					}
					result.push(renderObject(obj[key],thisPath,option,level))
				}
			}
		}
	} 
	//VALUE (string, number, boolean, or null (as string) )
	else {	
		//-T
		if(option.T) {
			//put result in an array escape whitespace chars, if -e is on escape here (we can't do it later because of indents)
			//if null was turned into a string do not futher encode
			if (typeof obj === "string" && ! isNull){
				//-EW encodeURI (repects protocol scheme and domain)
				if(option.encoding.W && !option.A){
					obj = encodeURI(obj)
				}
				//-Ew encodeURIComponent (encodes more for query encoding)
				else if(option.encoding.w && !option.A){
					obj = encodeURIComponent(obj)
				}			
				//encoding for everything else -E: b B E H h o O U u x 0 6 )
				else {
					var tempArray = [];
					//do not leave undefined
					var stringPadding='', spc='', open='', close=''

					//ESCAPED UTF-8 ENCODINGS
					//-Ex \xh hex shell style (UTF-8)
					if(option.encoding.x){var slice=-2, stringPadding="0", escStr="\\x", stringBase=16}
					//-E0 octal with leading zero \0nnn escapes (zsh)
					else if(option.encoding['0']){var escStr="\\0", stringBase=8, slice=-3, stringPadding="00"}
					//-EO \nnn octal no leading zero escapes
					else if(option.encoding.O){var stringPadding="00", escStr="\\", stringBase=8, slice=-3}
					//-Eu Unicode (UTF-16) \uxxxx
					else if(option.encoding.u){var escStr="\\u", stringPadding="0000", slice=-8, slice=-4, stringBase=16, utfEncoding=16}
					//ESCAPED CODE POINTS
					//-EU \U##### Unicode Code Point - zsh style 
					else if(option.encoding.U){var escStr="\\U", stringPadding="000000", slice=-8, stringBase=16}
					//-EE ES2015 Unicode Code Point Style \u{.....}
					else if(option.encoding.E){var escStr="\\u", stringPadding="", slice=0, open="{", close="}", stringBase=16}
					//NON-ESCAPED ENCODINGS
					//-Eo octal 0oXXXX escaping for octals used in strict compliant JS
					else if(option.encoding.o){var escStr="0o", stringBase=8, spc=" "}
					//-Eb binary UTF-8: 01101001 00001001
					else if(option.encoding.b){var escStr="0b", stringBase=2, stringPadding="0000000", spc=" ", slice=-8}
					//-EB UTF-16 8-wide and -E6 16 bit wide
					else if(option.encoding.B || option.encoding['6']){var escStr="0b", stringBase=2, stringPadding="000000000000000", spc=" ", slice=-16, utfEncoding=16}
					//-EH Hex (Uppercase) HH and -Eh Hex (lowercase) hh
					else if(option.encoding.h || option.encoding.H){ var slice=-2, stringPadding="0", escStr="0x", stringBase=16, spc=" "}
					//-EW and -Ew URI % encoding (for all)
					else if(option.encoding.W || option.encoding.w){var slice=-2, stringPadding="0", escStr="%", stringBase=16}

					//loop through each character
					for (var i=0; i < obj.length; i++) {
						var charcode = obj.charCodeAt(i);

						//widen range if -W is used
						var rangeRegex
						option.W ? rangeRegex=/[\u0000-\u001f\u005c\u007f\s\b]/ : rangeRegex=/[\u0000-\u001f\u005c\u007f]/

						if (charcode < 0x80) {
							//If whitespace or \ AND NOT encoding all (-A) and either a \ escaped format or not encoding at all
							//Encoding with \b \f \n \r \t \v (\v is not JSON fyi)
							if (/[\s|\b|\\]/.test(obj[i]) && ! option.A && (/^\\/.test(escStr) || !option.encoding)){
								//if -e AND using a \\ escaped encoding OR encoding is not set
								//escape all whitespace with literal strings
								if(option.e) {
									tempArray.push(obj[i].replace(/[\s|\b]/g, function(chr) { switch(chr) { case ' ': return " "; case '\b': return "\\b"; case '\f': return "\\f"; case '\n': return "\\n"; case '\r': return "\\r"; case '\t': return "\\t"; case '\v': return "\\v";}}))
								}
								//-W encode whitespace
								else if(option.W) {
									var b=escStr+open+(stringPadding + charcode.toString(stringBase)).slice(slice)+close;								
									tempArray.push(b + spc)							
								}
								//passthrough (this allows binary to use whitepsace switch)
								else {
									tempArray.push(obj[i]);
								}
							}
							//For b,B,o,h,H,w,W always encode
							//For E,U,u,x,O, 0 ONLY encode if -A OR in range: 00-1f, 5c,7f (-W will widen it)
							else if ((option.encoding.b || option.encoding.B || option.encoding['6'] || option.encoding.o || option.encoding.h || option.encoding.H || option.encoding.w || option.encoding.W) || ((option.encoding.U || option.encoding.E || option.encoding.O || option.encoding['0'] || option.encoding.u || option.encoding.x) && (rangeRegex.test(obj[i]) || option.A))) { 								
								//-U leaves whitespace untouched (not encoded)
								if (/[\s|\b]/.test(obj[i]) && option.U){
									tempArray.push(obj[i]);
								}
								//encode
								else {
									var b=escStr+open+(stringPadding + charcode.toString(stringBase)).slice(slice)+close;								
									tempArray.push((option.encoding.B ? b.slice(0,8) + "_" + b.slice(8) : b) + spc)							
								}
							}
							//pass-thru unencoded
							else {
								tempArray.push(obj[i]);
							}						
						}
						else if(! option.encoding){
							tempArray.push(obj[i]);
						}
						//utf-16 0x80 and above, easy
						else if (utfEncoding === 16 ){
							var b=(stringPadding + charcode.toString(stringBase)).slice(slice);
							tempArray.push(escStr+(option.encoding.B ? b.slice(0,8) + "_" + b.slice(8) : b) + spc)
						}
						//Code Point output -EE and -EU in here
						else if (option.encoding.U || option.encoding.E) {
							//pass-thru encoding
							if (charcode < 0xd800 || charcode >= 0xe000) {
								tempArray.push(escStr, open, (stringPadding + charcode.toString(16)).slice(slice), close);
							}
							//combine this charcode and the next get to get the code point
							else {
								i++;
								tempArray.push(escStr, open, (stringPadding + ((charcode - 0xD800) * 0x400 + obj.charCodeAt(i) - 0xDC00 + 0x10000).toString(16)).slice(slice), close);
							}
						}
						//else utf-8
						//Modified from: https://jonisalonen.com/2012/from-utf-16-to-utf-8-in-javascript/
						else {
							if (charcode < 0x800) {
								tempArray.push(escStr, (0xc0 | (charcode >> 6)).toString(stringBase), spc,
										  escStr,(0x80 | (charcode & 0x3f)).toString(stringBase), spc
								);
							}
							else if (charcode < 0xd800 || charcode >= 0xe000) {
								tempArray.push(escStr, (0xe0 | (charcode >> 12)).toString(stringBase), spc,
										  escStr, (0x80 | ((charcode>>6) & 0x3f)).toString(stringBase), spc, 
										  escStr, (0x80 | (charcode & 0x3f)).toString(stringBase), spc
								);
							}
							else {
								i++;
								charcode = 0x10000 + (((charcode & 0x3ff)<<10) | (obj.charCodeAt(i) & 0x3ff))
								tempArray.push(escStr, (0xf0 | (charcode >>18)).toString(stringBase), spc,
										  escStr, (0x80 | ((charcode>>12) & 0x3f)).toString(stringBase), spc,
										  escStr, (0x80 | ((charcode>>6) & 0x3f)).toString(stringBase), spc,
										  escStr, (0x80 | (charcode & 0x3f)).toString(stringBase), spc
								);
							}
						}
					}
					//join temp array and 
					obj=tempArray.join("");
					//just do the uppercase all at once 
					if(option.encoding.H){ obj=obj.toUpperCase() }
				}				
			}
			else if(obj.constructor === Number){
				//detmine the signedness
				if (Math.sign(obj) === -1){					
					//add this BEFORE encoding
					var possibleNegative="-"
					//make positive
					obj=(obj * -1)
				}
				else {
					var possibleNegative=""
				}
				if(obj === Infinity){
					if(option.I) {
						obj= possibleNegative + "Infinity"
					}
					else if (option.n){
						obj="null"
					}
					else {
						obj=""
					}
				}
				else if(option.encoding.b || option.encoding.B || option.encoding['6']) {
					//b and B are the same 8 bit wide, 6 will need 16 bit wide
					obj = Math.floor(obj).toString(2)
					if(option.encoding.b){
						var width=8
						var delineation=8
					}
					else if(option.encoding.B){
						var width=16
						var delineation=8
					}
					else if (option.encoding['6']) {
						var width=16
						var delineation=16
					}
					//get padding
					if (obj.length < width) {
						var padding=width - obj.length
					}
					else if (obj.length % width != 0 ) {
						var padding=width - (obj.length % width)
					}
					else {
						var padding=0
					}
					//nearest mutliple
					var widthMultiple=obj.length + padding
					//pad string to multiple length and trim
					if (option.encoding.b) { 
						obj = ("0000000" + obj).slice(-widthMultiple)
					}
					//pad both and delineate with _ according to width 
					else if(option.encoding.B || option.encoding['6']) { 	
						obj = ("000000000000000" + obj).slice(-widthMultiple) 
						//if -EB then make 8 bit wide
					}
					//delineate string with _ according to delineation
					for(var c=0, tempObj="";c<obj.length;c=c+delineation){
						var tempObj = tempObj + (c === 0 ? "" : "_") + obj.slice(c,c+delineation)
					}
					//reassign obj to new string
					obj = possibleNegative + "0b" + tempObj
				}
				else if(option.encoding.h || option.encoding.H) {
					//obj = possibleNegative + ("0" + (option.encoding.h ? obj.toString(16) : obj.toString(16).toUpperCase())).slice(-2)
					obj = possibleNegative + "0x" + ((obj < 0x10 ? "0" : "") + (option.encoding.h ? Math.floor(obj).toString(16) : Math.floor(obj).toString(16).toUpperCase()))
				}
				else if(option.encoding.o) {
					//b and B are the same 8 bit wide, 6 will need 16 bit wide
					//obj = ("00" + obj.toString(8)).slice(-3)
					obj = possibleNegative + "0o" + Math.floor(obj).toString(8)
				}
				else if(option.encoding.O) {
					//b is 8 bit wide, 6 will need 16 bit wide
					//obj = ("00" + obj.toString(8)).slice(-3)
					obj = possibleNegative + "0" + Math.floor(obj).toString(8)
				}
			}
			//final result is single indented JSON object in an array, stringified in case of Infinity
			result=[ indent + obj ]
		}
		//if -R or -J
		else if( (option.R || option.J) ) { 
			//get result ready to push this later
			result=[indent + pathName + (option.C ? typeString : '' ) ]; 
		}
		//-L
		else {			
			if (typeof obj === "string" && !isNull) {
				//escape whitespace
				var thisString = obj.replace((option.u ? /[\u0000-\u001f\u007f-\uffff|\\|"|']/g : /[\u0000-\u001f\u007f|\\|"|']/g), function(chr) { switch(chr) { case '\b': return "\\b"; case '\f': return "\\f"; case '\n': return "\\n"; case '\r': return "\\r"; case '\t': return "\\t"; case '\\': return "\\\\"; case '"': return (stringQuotes === "'" ? "\"" : "\\\"" ); case '\'': return (stringQuotes === "'" ? "\\'" : "'" ); default: return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4);}});
				result=[ pathName + '=' + stringQuotes + thisString + stringQuotes ]
			}
			//booleans and numbers don't get quotes, nor does a string with isNull set
			else result=[ pathName + '=' + obj ]
		}
	}
	return result.flat()
}

//normalize string expression into object containing, string numbers, arrays, or expression objects
function objectifyExpressions(array,option)
{
	option = option || {};
	//option.allowExpressions = allow JSONPath expressions
	//option.expandTrailingUnion = expand a union expression into discreet
	//option.disallowData - error if data is found along with path expression

	//fix non-comparison @ paths in filters like: "?(@.a || @['b'])" rewriting as ?(@.a!==undefined || @.b!==undefined)
	//fix negation ! by adding surrounding parens "?(@.a && !@['b'])" rewrites as ?(@.a!==undefined && !(@.b!==undefined))
	function fixFilterString(str) {
		//turn into an array
		str = str.split('');

		//a few of the modes we can be in
		var mode = {
			inDoubleQuote: false,
			inSingleQuote: false,
			inEscape: false,
			inRegexp: false,
			//either @ or $
			inPath: false,
			inKeyName: false,
			inBracket: false,
		};

		//last character of significance for a path name
		var lastPathChar
		var comparatorOp=false
		var negationCount=0
		var parenStack=[]
		
		//process string
		for (var i=0; i < str.length; i++) {

			//if not a keyname break out before we go
			if (mode.inKeyName && !/[$_A-Za-z0-9.]/.test(str[i])){
				mode.inKeyName=false
			}

			//ignore anything in quotes ' "
			if (mode.inDoubleQuote || mode.inSingleQuote) {   
				if (mode.inEscape) { mode.inEscape = false }
				else if (str[i] === '"' && mode.inDoubleQuote) { mode.inDoubleQuote = false; }
				else if (str[i] === "'" && mode.inSingleQuote){ mode.inSingleQuote = false; }
				else if (str[i] === '\\' ) { mode.inEscape = true }
			}
			//ignore whatever is inside a /.../ style regex (JSON Pointer RFC uses I-regex)
			else if (mode.inRegexp){
				if (mode.inEscape) { mode.inEscape = false }
				//forward slash / IS allowed in brackets
				else if (str[i] === '[') { mode.inBracket=true }
				else if (str[i] === ']') { mode.inBracket=false	}
				else if (str[i] === '/' && !mode.inBracket) { mode.inRegexp = false }
				else if (str[i] === '\\' ) { mode.inEscape = true }
			}
			//record our last place
			else if(mode.inKeyName){
				lastPathChar=i			
			}
			//beginning of JSON string in " quote ' quote
			else if (str[i] === '"' || str[i] === "'") {
				if (str[i] === '"'){ mode.inDoubleQuote = true; }
				else { mode.inSingleQuote = true; }
				lastPathChar = i
			}
			//beginning of a absolute or relative path, only dot and index (bracket) selectors allowed
			else if (str[i] === '$' || str[i] === '@') {
				//set this var
				lastPathChar = i
		
				//beginning of dot child key
				if (str[i+1] === '.') {
					mode.inKeyName=true
					lastPathChar=i				
				}	
			}
			//end of bracket
			else if (str[i] === ']') {
				lastPathChar=i
				mode.inBracket=false
				//wow should we test for bracket or . next?
				//test the next
				if (str[i+1] === "."){
					mode.inKeyName=true
					i++
				}		
			}
			//if we are not in a double quote then this should mean this is a regex
			else if (str[i] === '/' ) {
				mode.inRegexp = true
			}
			//if ==, !=, <=, or >=
			else if ((str[i] === '=' || str[i] === '!' || str[i] === '<' || str[i] === '>' || str[i] === '=' ) && str[i+1] === '=' ) {
				//reset
				lastPathChar=undefined
				//advance 1 for the equal sign
				i=i+1
				mode.inPath=false
				comparatorOp=true
			}
			//or just < or >
			else if (str[i] === '<' || str[i] === '>') {
				//reset
				lastPathChar=undefined
				mode.inPath=false
				comparatorOp=true
			}
			//or regex =~
			else if (str[i] === '=' && str[i+1] === '~' ) {
				//reset
				lastPathChar=undefined
				mode.inPath=false
				comparatorOp=true

				//advance 1
				i=i+1
			}
			//booleans: &&, ||
			else if ((str[i] === '&' && str[i+1] === '&') || (str[i] === '|' && str[i+1] === '|' )) {
				//if this wasn't reset then it never had a comparison applied
				if (comparatorOp != true && lastPathChar !== undefined) {
					//insert !== undefined into array after lastPathChar
					str.splice((lastPathChar+1),0,"!==undefined")
					i++
				}
				mode.inPath=false
				comparatorOp=false  	
				
				//close out negation !( with )
				if(negationCount){					
					for (var loop=0; loop<negationCount; negationCount--){
						str.splice(i,0,")")
						i++
					}
				}
			}
			else if(str[i] === '!'){
				//insert (
				str.splice(i+1,0,"(")
				negationCount++
				i++
			}
			//a paren beginning
			else if(str[i] === '('){				
				//store value in stack
				parenStack.unshift(negationCount)
				//reset count
				negationCount=0
			}
			//a paren beginning
			else if(str[i] === ')'){
				//close out 
				if(negationCount){					
					for (var loop=0; loop<negationCount; negationCount--){
						str.splice(i+1,0,")")
						i++
					}
				}	
				//get any previous values in stack
				negationCount=parenStack.shift()
			}

			//end of for loop for str -2 as we currently expect parens surrounding all
			if(i == (str.length-2)){
				if(comparatorOp != true && lastPathChar !== undefined) {
					//insert at the end
					str.splice((lastPathChar+1),0,"!==undefined")
					i++
				}				
				//insert remaining ) at the end
				if(negationCount){
					//insert (
					for (var loop=0; loop<negationCount; negationCount--){
						str.splice(i+1,0,")")
						i++
					}
				}
			}
		}
		var finalString = str.join('')
		return finalString
	}

	try {
		//go through the array of object literals and paths, remove any empty lines
		array = array.map(function(expr){
				var pathStack=[]
				var baldRecursion=false				
				var assignmentLocations=[]
				//trim any leading/trailing whitespace
				expr=expr.replace(/^\s*/,"").replace(/\s*$/,"")

				//be nice to jq folks who just want the document with . (not edge case keypath $[''][''])
				if(expr === "."){
					if(option.c){printErr("jq-style query '.' treated as JSONPath '$'")}
					expr='$'
				}


				//JSON Pointer if empty string "" or begins with /
				if((expr === "" || expr[0] === "/") ){					
					
					//only ~0 amd ~1 are valid, nothing else with ~ is
					if (/~[^0-1]/g.test(expr+' ')){
						throw new SyntaxError("JSON Pointer allows ~0 and ~1 only: " + expr)
					}
					
					option.allowExpressions=false
					//split into array on /
					pathStack = expr.split('/')
					//throw out first entry
					pathStack.shift()
					//replace special symbols with actual characters
					pathStack = pathStack.map(function (f){ 
						return f.replace(/~1/g,"/").replace(/~0/g,"~") })
					if(pathStack[pathStack.length-1] === "-"){ pathStack[pathStack.length-1] = {"expression":"-"} }
				}
				//process as either JSONPath or keypath
				else {
					//JSONPath with ugly jq style .[ beginning
					if (expr[0] === "." && expr[1] === "[") { 
						expr = "$" + expr.slice(1,);
						if(option.c){printErr("jq-style '.[' beginning, treated as JSONPath '$['")}
					}
					//JSONPATH with either . or [ (but not ..) at beginning probably jq stle
					else if ((expr[0] === "." && expr[1] !== ".") || expr[0] === "[") { 
						expr = "$" + expr ;
						if(option.c){printErr("Query lacks root '$', trying as JSONPath...")}
					}
					//otherwise try as keypath, '..' treated as keypath is $[''][''][''] fyi
					else if(expr[0] !== "$") {	
						//previously was considered an unknown query type
						//throw new SyntaxError("Unrecognized query syntax: " + expr)					
						//now perhaps it is plutil-style keypath
						if(option.c){printErr("Query lacks root '$', trying as keypath...")}
						//use illegal \uDEAD for escaped dots \. when breaking out into keys
						expr='$'+expr.replace("\\.","\uDEAD").split(".").map(function (f){return "["+JSON.stringify(f.replace("\uDEAD","."))+"]"}).join('')						
					}
										
					//reverse expr to use regex negative lookahead to ignore strings
					var revExpr = expr.split('').reverse().join('')
					// replace everything in quotes "..." '...' and regexes =~ /.../ with spaces
					// replace assignment operators with spaces: == === != !== <= >= =~
					var tempExpr=revExpr.replace(/(["'])(.*?)\1(?!\\)|(\/.*?\/(?!\\)\s*~=)|=~*\s(\/.*?\/(?!\\))|(={2,3})[^=]|[^=](==?!)|[^=]((?:=!|=<|=>|~=))/g, function(a){return a.replace(/./g, " ")})

					//find equals sign in the string
					var assignmentRegex=/=/g
					var assignmentLocations=[]
					var lastAssignmentLastIndex=0
					var assignmentMatch=[]

					//check if there is an assignment operator =
					do {
						assignmentMatch=assignmentRegex.exec(tempExpr)
						//break if stuck or not found
						if (assignmentMatch === null || assignmentRegex.lastIndex === 0|| lastAssignmentLastIndex === assignmentRegex.lastIndex) { 
							break ;
						}
						//note the last match - this should be the only one
						lastAssignmentLastIndex = assignmentRegex.lastIndex
						assignmentLocations.unshift(lastAssignmentLastIndex)
					} while(assignmentRegex.lastIndex !== 0 && assignmentRegex.lastIndex !== tempExpr.length)
					//throw an error if we are NOT allowing JSON Path object literals and we get something
					if(option.disallowData && assignmentLocations.length){
						throw new SyntaxError("Data assignment (=) not allowed in path specification")
					}
					//throw an error if multiple =
					else if(assignmentLocations.length > 1) { 
						throw new SyntaxError("Multiple assignment operators detected: " + expr)
					}

					//trim expr to ONLY have path and reverse it to be revExpr
					if(expr.length - lastAssignmentLastIndex > 0){
						//expr = expr.substring(0,expr.length - lastAssignmentLastIndex).split('').reverse().join('')
						var revExpr = expr.substring(0,expr.length - lastAssignmentLastIndex).split('').reverse().join('')
					}
					//this may never be reachable
					else{
						throw new Error("Error parsing: " + expr)
					}

					var hasRoot, lastLastIndex=0;
					//begin JSONPath parsing
					//regex in reverse to use negative lookahead assertions to parse strings with escaped quotes, (see webkit "bug": 174931)
					//L1 structures: dotted keys, dotted star, opening bracket and $
					var Level1Regex = /([\w\d$]*[A-Za-z_$])(\.{1,2})|(\*?)(\.{1,2})|(\])|(\$)/g
					do {
						//run regex, get a match
						var L1Match = Level1Regex.exec(revExpr); 
						if(L1Match === null) { break }
						//check if there is a difference from the length of the L1Match , if not we are stuck
						if((lastLastIndex+L1Match[0].length) !== Level1Regex.lastIndex || L1Match[0] === "" ){
							throw new SyntaxError("Malformed path expression: " + expr)
						}
						//.key1 or ..key2 - ([\w\d$]*[A-Za-z_$])(\.{1,2})
						//.* or ..* - (\*?)(\.{1,2})
						if(L1Match[1] || L1Match[3]) {
							if(baldRecursion){throw new SyntaxError("Additional operators (./..) disallowed after recursive descent: " + expr)}
							//filter out nulls
							L1Match=L1Match.filter(function(p) { return p != null })

							if(L1Match[1] === '*') { 
								if(!option.allowExpressions) {throw new SyntaxError("JSONPath expressions disallowed: " + expr)}
								pathStack.unshift({"expression":"*"}) 
							}
							else if(L1Match[1]) { pathStack.unshift(L1Match[1].split('').reverse().join('')) }
							if (L1Match[2] === '..') { 
							if(!option.allowExpressions) {
								throw new SyntaxError("JSONPath expressions disallowed: " + expr)}
								pathStack.unshift({"expression":".."}) 
							}
							else if(L1Match[1] === '') { Level1Regex.lastIndex=lastLastIndex;  break }
						}
						//(\*?)(\.{1,2}) - just the dots ..
						else if(L1Match[4]) {							
							if(L1Match[4] === '.'){ break }
							else if(!pathStack.length){ baldRecursion=true; break }
							else if (pathStack[0].expression === "..") {
								throw new SyntaxError("Additional operators (./..) disallowed after recursive descent: " + expr)
							}
							pathStack.unshift({"expression":".."})
						}
						// (\]) - begin intra-bracket processing
						else if(L1Match[5]) {
							baldRecursion = false
							//L2 intra-bracket regex: quoted keys, star, number, dash, commas, colons, closed parens (begin), open bracket (end) and space
							var Level2Regex=/\s*(["'])(.*?)\1(?!\\)|(\*(?!:\*))|(\d+\-?)|(-)|(,)|(:)|(\))|(\[)|\s/g
							var subArray=[], L2Match=[], subLastLastIndex=Level1Regex.lastIndex, pendingData=[], intraSlice=false, needsDelimiter=false, isSlice=false;
							var openBracket=0, closedBracket=1;
							//set L2Regex to where we are in L1regex
							Level2Regex.lastIndex = Level1Regex.lastIndex				
							do {
								//get a L2Match match to the exec on revExpr
								L2Match=Level2Regex.exec(revExpr)
								//catch loops with lastIndex not advancing
								if (L2Match === null || subLastLastIndex === Level2Regex.lastIndex || subLastLastIndex + L2Match[0].length !== Level2Regex.lastIndex ) {
									throw new SyntaxError("Malformed path expression : " + expr)
								}
								//reverse things back
								L2Match = L2Match.map(function(s){return (!s ? s : s.split('').reverse().join(''))})
								//'key' or "key" - (["'])(.*?)\1(?!\\)
								if(L2Match[2] === ''){ subArray.unshift(L2Match[2]) }
								else if(L2Match[2]){
									if (needsDelimiter) { Level2Regex.lastIndex=subLastLastIndex; break; } else { needsDelimiter=true }
									if (intraSlice) { break }
									//depending on the quoting method unescape/re-escape then JSON parse
									pendingData.unshift(JSON.parse('"'+(L2Match[1] === "'" ? L2Match[2].replace(/\\'/g,"'").replace(/\"/g,"\\\"") : L2Match[2])+'"',null,0))
								}
								//* - (\*)
								else if(L2Match[3]){
									if(!option.allowExpressions) {throw new SyntaxError("JSONPath expressions disallowed: " + expr)}
									if (needsDelimiter) { Level2Regex.lastIndex=subLastLastIndex; break; } else { needsDelimiter=true }
									if (intraSlice) { break }
									else { pendingData.unshift({"expression":"*"}) }
								}
								//(\d+\-?) - integers positive or negative 
								else if(L2Match[4]){
									if (needsDelimiter && !isSlice) { Level2Regex.lastIndex=subLastLastIndex; break; } else { needsDelimiter=true }
									if (isSlice && intraSlice) { intraSlice=false }
									//catch octals indices regardless of strict mode
									if (L2Match[4] !== "0" && (L2Match[4][0] === "0" || (L2Match[4][0] === "-" && L2Match[4][1] === "0"))){
										throw new Error("Octal indices are disallowed: " + L2Match[4])
									}
									else{
										pendingData.unshift(Number(L2Match[4]))
									}
								}
								//(-) - from JSON Pointer, represents the index AFTER the last one, always non-existent
								else if(L2Match[5]){
									if (needsDelimiter) { Level2Regex.lastIndex=subLastLastIndex; break; } else { needsDelimiter=true }
									pendingData.unshift({"expression":"-"})
								}
								//(,) - time to write what we have and move on
								else if(L2Match[6]){
									if(!option.allowExpressions) {throw new SyntaxError("JSONPath expressions disallowed: " + expr)}
									//write any pending data we have
									if (pendingData.length && !isSlice){
										//pending is simply a number
										subArray.unshift(pendingData[0])
									}
									//tidy up slice array if we are moving on
									else if (pendingData.length){
										if(isSlice && intraSlice){ pendingData.unshift(null) }
										//slice expression (numbers and/or filter expression)
										subArray.unshift({"expression":pendingData})
									}
									//reset
									pendingData=[], needsDelimiter=false
									if (isSlice) { intraSlice=false; isSlice=false }
								}
								//(:) - colon (:)
								else if(L2Match[7]){
									if(!option.allowExpressions) {throw new SyntaxError("JSONPath expressions disallowed: " + expr)}
									isSlice=true
									// if we have something pending already, examine it
									// break if we have a ?() expression or a string or some other garbage...
									if (pendingData.length === 1 && pendingData[0] !== null && (pendingData[0].constructor === String || !(pendingData[0].constructor === Number || pendingData[0].expression[0] === "(" ))){
										break
									}

									//if nothing pending or we had previous colon, insert a colon to represent an empty slice slot ::
									if(!pendingData.length || intraSlice) { pendingData.unshift(null) } 

									//change state
									if (!intraSlice) { intraSlice=true }
								}
								//(\)) - closing parens, the beginning of our reverse regex
								else if(L2Match[8]){
									if(!option.allowExpressions) {throw new SyntaxError("JSONPath expressions disallowed: " + expr)}

									var openParens=0, closeParens=1, L3Match=[]

									//we will collect the entire ?()/() statement and then push in subArray
									var filterText=L2Match[8]

									//L3 regex: quoted strings, open parens, closed parens, ruby style regex (L), ruby style regex (R), equals sign, and arbitrary characters
									var Level3Regex=/(["'])(.*?)\1(?!\\)|(\()|(\))|(\/.*?\/(?!\\)\s*~=)|(~=\s*\/.*?\/(?!\\))|(==?((?:=|!)))|(.)/g

									if (isSlice) { intraSlice = false }
									else if (needsDelimiter) { break }

									//set our start point to be the same as where we are
									Level3Regex.lastIndex = Level2Regex.lastIndex
									do {
										//keep working on revExpr
										L3Match = Level3Regex.exec(revExpr)

										//(["'])(.*?)\1(?!\\) - quoted string
										//escape @ for substitution in P.eval
										if(L3Match[1]) { 
											filterText+=L3Match[0].replace(/@/g, "@\\")
										}				
										//(\() - open parens
										else if(L3Match[3]) {
											filterText+=L3Match[3]
											openParens += 1
										}
										//(\)) - close parens
										else if(L3Match[4]) {
											filterText+=L3Match[4]
											closeParens += 1
										}
										//(\/.*?\/(?!\\)\s*~=) - characters inside =~ /.../
										//(~=\s*\/.*?\/(?!\\)) - characters inside /.../ =~
										else if(L3Match[5]||L3Match[6]) { 
											//escape @ for escaping substitution in P.eval
											filterText+=L3Match[0].replace(/@/g, "@\\")
										}								
										//(==?((?:=|!))) - normalizes == and != to their strict equality equivalents
										else if(L3Match[7]) { 
											//rewrite to === or !== (reversed)
											filterText+="==" + L3Match[8]
										}
										//(.) - any other character
										else if(L3Match[9]) { 
											//if this is a = assignment (not != <= >=) break, =~ regex is matched earlier
											if(L3Match[9] === "=" && !/[<>!]/.test(revExpr[Level3Regex.lastIndex])) { 
												break
											}
											filterText+=L3Match[9]
										}
										if (closeParens === openParens){
											needsDelimiter=true
											//before we break check if the next char is a question mark and if so include that
											if(revExpr[Level3Regex.lastIndex] === '?'){
												if(isSlice){
													Level3Regex.lastIndex=0
													break
												}
												filterText+="?"
												Level3Regex.lastIndex = Level3Regex.lastIndex+1
											}
											//set our Level2Regex index to where we were in this
											Level2Regex.lastIndex = Level3Regex.lastIndex
											//reverse back to normal and store this in the array of items
											var filterTextFinal = fixFilterString(filterText.split('').reverse().join(''))
											pendingData.unshift({"expression":filterTextFinal})
											break;
										}
									} while (Level3Regex.lastIndex !== 0 && Level3Regex.lastIndex !== revExpr.length)

									if (closeParens !== openParens) { break }
								}

								// (\[) - open bracket, the end of L2 for now
								else if(L2Match[9]){

									//empty brackets
									if(Level2Regex.lastIndex - Level1Regex.lastIndex === 1) {
										break
									} 
									else {
										Level1Regex.lastIndex = Level2Regex.lastIndex
										break									
									}
								}
								//\s* - spaces just advance on...
								//catch if we skip ahead or are stuck next match
								subLastLastIndex=Level2Regex.lastIndex					
							} while(Level2Regex.lastIndex !== 0 && Level2Regex.lastIndex !== revExpr.length )

							//if there is a pending number, write it
							if(pendingData.length === 1 && !isSlice) { 
								subArray.unshift(pendingData[0]) 
							}
							else if (pendingData.length){
								//for leading : insert a null
								if(isSlice && intraSlice){ pendingData.unshift(null) }
								//for cases with only one : make the last entry null
								if(pendingData[2] === undefined){ pendingData[2] = null }
								subArray.unshift({"expression":pendingData})
							}
							
							//put the whole array in the pathStack array, trace will handle unbundling
							if(subArray.length > 1){ 
								if(!option.allowExpressions) {throw new SyntaxError("JSONPath expressions disallowed: " + expr)}
								pathStack.unshift(subArray) 
							}
							//save trace some work with just a single non-array entry
							else { pathStack.unshift(subArray[0]) }
						}
						// (\$) - only valid at the beginning
						else if(L1Match[6]){
							//if it's at the end (beginning) it is the root designator
							if(Level1Regex.lastIndex === revExpr.length){ hasRoot=true }
							else { break }
						}
						//to catch later if we skip ahead from a bad match or not...
						lastLastIndex=Level1Regex.lastIndex
					} while(Level1Regex.lastIndex !== 0 && Level1Regex.lastIndex !== revExpr.length )

					if (!hasRoot || baldRecursion || Level1Regex.lastIndex !== revExpr.length && !lastAssignmentLastIndex) { 
						throw new SyntaxError("Malformed path expression: " + expr) 
					}
				}
				//now that we know our path context...
				//if only one equal = create assignmentData, assignmentData_obj
				if (assignmentLocations.length === 1){
					//catch special case if odd numbered === assignment operator used, skip it, == will fail too
					if(expr.charAt(expr.length - lastAssignmentLastIndex-1) === "="){ return ''}

					//get the string representation, we will attempt to parse it later...
					var assignmentData = expr.substring(expr.length - lastAssignmentLastIndex + 1, expr.length)

					//detect single quotes ' and change to " escaping if necessary, to parse as JSON string
					if(assignmentData.match(/^'(.*)'$/)){
						//un-escape all single and double quotes (to be sure), then escape single quotes, wrap in double quotes
						assignmentData='"' + assignmentData.substring(1,assignmentData.length-1).replace(/\\"/g, '"').replace(/\\'/g, "'").replace(/"/g, '\\"') + '"'
					}
					//JSON.parse can do the work to validate and convert to object form
					try { 
						var assignmentData_obj = JSON.parse(assignmentData) 
					} 
					catch(e) {
						throw new SyntaxError(e + ": " + assignmentData)
						//return ''
					}
				}
				//return the pathStack object not a re-stringified version
				//if we have a pathStack, it's last member is an array and the option to expand it is on
				if(pathStack.length && pathStack[pathStack.length-1].constructor === Array && option.expandTrailingUnion){
					var returnObject=[]
					var basePath=pathStack.slice()
					var childUnion=basePath.pop()
					for(var i=0; i<childUnion.length; i++){
						var thisChild=childUnion[i]
						var tempBasePath=basePath.slice()
						tempBasePath.push(thisChild)
						returnObject.push({"path":tempBasePath,"data":assignmentData_obj})
					}
					return returnObject
				}
				else {
					//return pathStack
					var returnObject={"path":pathStack,"data":assignmentData_obj}
					return returnObject
				}

			})
		} catch(e) {throw new Error(e)}

	//filter out any empties, flat() is for the expandTrailingUnion which returns an array in an array
	return array.filter(function(e) {return e}).flat()
}

//recursively sort object keys alphabetically
function sortObject(obj) { 
	if (Array.isArray(obj)) { var seed = [] }
	else if (typeof obj === "object" && obj !== null) { var seed = {} }
	else { return obj }
    return Object.keys(obj).sort().reduce(function (result, key) {
        if (typeof obj[key] === "object") { result[key] = sortObject(obj[key]) }
        else { result[key] = obj[key] };
        return result;
    }, seed);
}

//flattens arrays of arrays, objects with arrays are left alone 
//https://stackoverflow.com/a/30048623/2030005
function flatten() {
    var flat = [];
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] instanceof Array) {
            flat.push.apply(flat, flatten.apply(this, arguments[i]));
        } else {
            flat.push(arguments[i]);
        }
    }
    return flat;
}

//jsc lacked flat() in 10.4-10.7
//https://github.com/jonathantneal/array-flat-polyfill/blob/master/src/polyfill-flat.js
if (!Array.prototype.flat) {
	Object.defineProperty(Array.prototype, 'flat', {
		configurable: true,
		value: function flat () {
			var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
			return depth ? Array.prototype.reduce.call(this, function (acc, cur) {
				if (Array.isArray(cur)) {
					acc.push.apply(acc, flat.call(cur, depth - 1));
				} else {
					acc.push(cur);
				}

				return acc;
			}, []) : Array.prototype.slice.call(this);
		},
		writable: true
	});
}

//sortVarWidth - sort a list alphabetically but grouped by line width
Object.defineProperty(Array.prototype, 'sortVarWidth', {
	configurable: true,
	value: function sortVarWidth() {
		//save ref of this as that for when we go into a call
		var that = this
		//get array of string lengths, filter for uniqs, sort numerically
		var sortedUniqLengths = Array.prototype.map.call(this, function(e){ return e.length })
		.filter(function(v, i, arr) { return i == arr.indexOf(v); })
		.sort(function(a, b) {return a - b;});
		//go through array smallest to deepest
		var sortedArray=[]
		Array.prototype.forEach.call(sortedUniqLengths, function(l){
			var chunk = Array.prototype.filter.call(that, function(e){ return e.length == l })
			sortedArray.push(chunk.sort())
		})			
		return sortedArray.flat()
	},
	writable: true
});

//escape special chars in string if used in regex
RegExp.quote = function(str) {
	return str.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
};

//Math.sign pollyfill
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
if (!Math.sign) {
  Math.sign = function(x) {
    return ((x > 0) - (x < 0)) || +x;
  };
}

// JSONPatch.js - A Dharmafly project written by Thomas Parslow <tom@almostobsolete.net> and released with the kind permission of NetDev.
//Copyright 2011-2013 Thomas Parslow. All rights reserved.
//Copyright 2020 Joel Bruner - bug fixes
(function (root, factory) {
	if (typeof exports === 'object') {
		// Node
        factory(module.exports);
    } 
    else if(typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['exports'], factory);
    } 
    else {
        // Browser globals (root is window)
        root.jsonpatch = {};
        root.returnExports = factory(root.jsonpatch);
	}
}
(this, function (exports) {
	var apply_patch, JSONPatch, JSONPointer,_operationRequired,isArray;
	// Taken from underscore.js

	isArray = Array.isArray || function(obj) {
		return Object.prototype.toString.call(obj) == '[object Array]';
	};

	exports.apply_patch = apply_patch = function (doc, patch) {
		return (new JSONPatch(patch)).apply(doc);
	};

	function InvalidPatch(message) {
		Error.call(this, message); this.message = message;
	}

	exports.InvalidPatch = InvalidPatch;

	InvalidPatch.prototype = new Error();

	function PatchApplyError(message) {
		Error.call(this, message); this.message = message;
	}

	exports.PatchApplyError = PatchApplyError;

	PatchApplyError.prototype = new Error();

	exports.JSONPointer = JSONPointer = function JSONPointer (pathStr) {
		var i,split,path=[];
		split = pathStr.split('/');
		if ('' !== split[0]) {
			throw new InvalidPatch('JSONPointer must start with a slash (or be an empty string)!');
		}
		for (i = 1; i < split.length; i++) {
			path[i-1] = split[i].replace(/~1/g,'/').replace(/~0/g,'~');
		}
		this.path = path;
		this.length = path.length;
	};
	JSONPointer.prototype._get_segment = function (index, node) {
		var segment = this.path[index];
		if(isArray(node)) {
			if ('-' === segment) {
				segment = node.length;
			} 
			else {
				// Must be a non-negative integer in base-10 without leading zeros
				if (!segment.match(/^0$|^[1-9][0-9]*$/)) {
					throw new RangeError('Invalid array index: ' + segment);
				}
				segment = parseInt(segment,10);
			}
		}
		return segment;
	};
	// Return a shallow copy of an object
	function clone(o) {
		var cloned, key;
		if (isArray(o)) {
			return o.slice();
			// typeof null is "object", but we want to copy it as null
		}
		if (o === null) {
			return o;
		}
		else if (typeof o === "object") {
			cloned = {};
			for(key in o) {
				if (Object.hasOwnProperty.call(o, key)) {
					cloned[key] = o[key];
				}
			}
			return cloned;
		} 
		else {
			return o;
		}
	}
	JSONPointer.prototype._action = function (doc, handler, mutate) {
		var that = this;
		function follow_pointer(node, index) {
			var segment, subnode;
			if (!mutate) {
				node = clone(node);
			}
			segment = that._get_segment(index, node);
			// Is this the last segment?
			if (index == that.path.length-1) {
				node = handler(node, segment);
			} 
			else {
				// Make sure we can follow the segment
				if (isArray(node)) {
					if (node.length <= segment) {
						throw new PatchApplyError('Path not found in document');
					}
				}
				else if (typeof node === "object") {
					if (!Object.hasOwnProperty.call(node, segment)) {
						throw new PatchApplyError('Path not found in document');
					}
				} 
				else {
					throw new PatchApplyError('Path not found in document');
				}
				subnode = follow_pointer(node[segment], index+1);
				if (!mutate) {
					node[segment] = subnode;
				}
			}
			return node;
		}
		return follow_pointer(doc, 0);
	};
	JSONPointer.prototype.add = function (doc, value, mutate) {
		// Special case for a pointer to the root
		if (0 === this.length) {
			return value;
		}
		return this._action(doc, function (node, lastSegment) {
			if (node === null) {
				throw new Error('Unable to add to null!')
			}
			else if (isArray(node)) {
				if (lastSegment > node.length) {
					throw new RangeError("Array index '" + lastSegment + "' does not exist. Use '-' to add to the end.");
				}
				node.splice(lastSegment, 0, value);
			} 
			else {
				node[lastSegment] = value;
			}
			return node;
		}, mutate);
	};
	JSONPointer.prototype.remove = function (doc, mutate) {
		// Special case for a pointer to the root
		if (0 === this.length) {
			//return empty array like jsonPath
			return [];
		}
		return this._action(doc, function (node, lastSegment) {
			if (!Object.hasOwnProperty.call(node,lastSegment)) {
				throw new PatchApplyError('Remove operation must point to an existing value!');
			}
			if (isArray(node)) {
				node.splice(lastSegment, 1);
			} 
			else {
				delete node[lastSegment];
			}
			return node;
		}, mutate);
	};
	JSONPointer.prototype.replace = function (doc, value, mutate) {
		// Special case for a pointer to the root
		if (0 === this.length) {
			return value;
		}
		return this._action(doc, function (node, lastSegment) {
			if (node === null) {
				throw new Error('Unable to replace to null!')
			}
			else if (!Object.hasOwnProperty.call(node,lastSegment)) {
				throw new RangeError("Replace requires an existing location. Property '" + lastSegment + "' not found.");
			}
			if (isArray(node)) {
				node.splice(lastSegment, 1, value);
			} 
			else {
				node[lastSegment] = value;
			}
			return node;
		}, mutate);
	};
	JSONPointer.prototype.get = function (doc) {
		var value;
		if (0 === this.length) {
			return doc;
		}
		this._action(doc, function (node, lastSegment) {
			if (!Object.hasOwnProperty.call(node,lastSegment)) {
				throw new PatchApplyError('Path not found in document');
			}
			value = node[lastSegment];
			return node;
			}, true);
		return value;
	};
	JSONPointer.prototype.subsetOf = function (otherPointer) {
		if (this.length <= otherPointer.length) {
			return false;
		}
		for (var i = 0; i < otherPointer.length; i++) {
			if (otherPointer.path[i] !== this.path[i]) {
				return false;
			}
		}
		return true;
	};
	_operationRequired = {
		add: ['value'],
		replace: ['value'],
		test: ['value'],
		remove: [],
		move: ['from'],
		copy: ['from']
	};
	// Check if a is deep equal to b (by the rules given in the JSONPatch spec)
	function deepEqual(a,b) {
		var key;
		if (a === b) {
			return true;
		} 
		else if(typeof a !== typeof b) {
			return false;
		}
		else if ('object' === typeof(a)) {
			var aIsArray = isArray(a),
			bIsArray = isArray(b);
			if (aIsArray !== bIsArray) {
				return false;
			} 
			else if (aIsArray) {
				// Both are arrays
				if (a.length != b.length) {
					return false;
				} 
				else {
					for (var i = 0; i < a.length; i++) {
						if(! deepEqual(a[i], b[i])){
							return false
						}
					}
					return true
				}
			} 
			//Object - the original code was sorely broken
			else {
				//quickly see if they have the same number of objects
				if (Object.keys(a).length !== Object.keys(b).length) { return false }
								
				// Check each key of the object recursively
				for(key in a) {
					if (!b.hasOwnProperty(key) || ! deepEqual(a[key], b[key])) {
						return false;
					}
				}
				return true;
			}
		} 
		else {
			return false;
		}
	}
	function validateOp(operation) {
		var i, required;
		if (!operation.op) {
			throw new InvalidPatch('Operation missing');
		}
		if (!_operationRequired.hasOwnProperty(operation.op)) {
			throw new InvalidPatch('Invalid JSON Patch operation');
		}
		if (!('path' in operation)) {
			throw new InvalidPatch('Path missing');
		}

		required = _operationRequired[operation.op];
		// Check that all required keys are present
		for(i = 0; i < required.length; i++) {
			if(operation[required[i]] === undefined) {
				throw new InvalidPatch(operation.op + ' must have key ' + required[i]);
			}
		}
	}
	function compileOperation(operation, mutate) {
		validateOp(operation);
		var op = operation.op;
		var path = new JSONPointer(operation.path);
		var value = operation.value;
		var from = operation.from !== undefined ? new JSONPointer(operation.from) : null;

		switch (op) {
			case 'add':
				return function (doc) {
					return path.add(doc, value, mutate);
				};
			case 'remove':
				return function (doc) {
					return path.remove(doc, mutate);
				};
			case 'replace':
				return function (doc) {
					return path.replace(doc, value, mutate);
				};
			case 'move':
				// Check that destination isn't inside the source
				if (path.subsetOf(from)) {
					throw new InvalidPatch('destination must not be a child of source');
				}
				return function (doc) {
					var value = from.get(doc);
					var intermediate = from.remove(doc, mutate);
					return path.add(intermediate, value, mutate);
				};
			case 'copy':
				return function (doc) {
					var value = from.get(doc);
					return path.add(doc, value, mutate);
				};
			case 'test':
				return function (doc) {
					//original code did not work with objects (all objects matched regardless of contents) and arrays (only differing member counts detected)
					if (!deepEqual(path.get(doc), value)) {
						throw new PatchApplyError("Test operation failed. Values did not match.");
					}
				return doc;
			};
		}
	}
	exports.JSONPatch = JSONPatch = function JSONPatch(patch, mutate) {
		this._compile(patch, mutate);
		};
	JSONPatch.prototype._compile = function (patch, mutate) {
		var i, _this = this;
		this.compiledOps = [];

		if ('string' === typeof patch) {
			patch = JSON.parse(patch);
		}
		if(!isArray(patch)) {
			throw new InvalidPatch('Patch must be an array of operations');
		}
		for(i = 0; i < patch.length; i++) {
			var compiled = compileOperation(patch[i], mutate);
			_this.compiledOps.push(compiled);
		}
	};
	exports.JSONPatch.prototype.apply = function (doc) {
		var i;
		for(i = 0; i < this.compiledOps.length; i++) {
			doc = this.compiledOps[i](doc);
		}
		return doc;
	};
}));

//Copyright (c) 2016 Kris Nye - MIT License
function isObject(a) {
	var type = typeof a;
	return a != null && (type === 'object' || type == 'function')
}

//Copyright (c) 2016 Kris Nye - MIT License
function diff(oldValue, newValue) {
    // returns a patch which can convert from the oldValue to the newValue
    // returns undefined if there is no difference between them
    // the patch SHOULD be treated as readonly, since it may reference pre-existing objects
    if (oldValue == newValue) {
        return undefined;
    }
    if (!(oldValue != null && newValue != null && typeof newValue === 'object' && typeof oldValue === 'object')) {
        return newValue != null ? newValue : null;
    }
    if (!Array.isArray(oldValue) && Array.isArray(newValue)) {
        return newValue;
    }
    // old == array, but new isn't, so we add a special length:null value
    if (Array.isArray(oldValue) && !Array.isArray(newValue)) {
        var newValue = JSON.parse(JSON.stringify(newValue));
        // this indicates that the array must be converted to an object.
        newValue.length = null;
        return newValue;
    }
    var patch = undefined;
    for (var name in oldValue) {
        if (oldValue.hasOwnProperty(name)) {
            if (!newValue.hasOwnProperty(name)) {
                if (patch == null) {
                    patch = {};
                }
                patch[name] = null;
            }
            else {
                var propertyDiff = diff(oldValue[name], newValue[name]);
                if (propertyDiff !== undefined) {
                    if (patch == null) {
                        patch = {};
                    }
                    patch[name] = propertyDiff;
                }
            }
        }
    }
    for (var name in newValue) {
        if (newValue.hasOwnProperty(name) && !oldValue.hasOwnProperty(name)) {
            if (patch == null) {
                patch = {};
            }
            patch[name] = newValue[name];
        }
    }
    // if they are both arrays and the new value is shorter, then shorten the length
    if (Array.isArray(oldValue) && Array.isArray(newValue) && newValue.length < oldValue.length) {
        patch.length = newValue.length;
        for (var i = newValue.length; i < oldValue.length; i++) {
            delete patch[i];
        }
    }
    return patch;
}

//Copyright (c) 2016 Kris Nye - MIT License
function merge(target, patch, deleteNull,mergeOption) {

    // length: null when targetting an Array indicates to convert Array to Object.
    if (Array.isArray(target) && patch != null && patch.length === null) {      
        target = {};
        delete patch.length;
    }

    if (patch == null || (patch != null && patch.constructor !== Object)) {
        if (Array.isArray(patch)) {
            return JSON.parse(JSON.stringify(patch));
        }
        else {
            return patch;
        }
    }
    if (!isObject(target)) {
        target = {};
    }

    var deletedValues = false;
    for (var key in patch) {
        var value = patch[key];
        if (deleteNull && value == null) {
            deletedValues = true;
            delete target[key];
        }
        else {
        	//if key DOES NOT exist DO NOT merge
        	if (target[key] === undefined && mergeOption && mergeOption.existingOnly == true){
        		continue
        	}
        	//if key DOES exist DO NOT merge
        	else if (target[key] !== undefined && mergeOption && mergeOption.nonexistingOnly == true){
        		continue
        	}        	
            target[key] = merge(target[key], value, deleteNull, mergeOption);
        }
    }
    if (deletedValues && Array.isArray(target)) {
        // shorten the length
        for (var i = target.length; i > 0; i--) {
            if (target[i - 1] == null) {
                target.length = i - 1;
            }
        }
    }
    return target;
}

function ingestLiterals(valueString,option,$)
{
	//turn into array, remove empty lines
	var literalStrings = valueString.split('\n').filter(function(p) { return p != null && p != ''; })	
	//ingest the JSON Path Literals without using eval()
	//get back object representation of literals
	try { var literalObjects = objectifyExpressions(literalStrings) } catch(e){throw new Error(e)}	

	//get back an array of objects containing keys "path" and (perhaps) "data"
	//path is an array of String or Number elements
	//loop through each literal object in the literalObjects array
	for (var i=0 ; i<literalObjects.length; i++){
		var thisLitObj=literalObjects[i]
		var thisPath=thisLitObj.path
		var thisData=thisLitObj.data

		//each time back at the top
		var thisNode=$
		//no length means root
		if(!thisPath.length){
			if ($ !== undefined && option.G) {
				printErr("Guarding $ from root overwrite, line: " + (i+1))
			}
			else {
				if(thisData !== undefined) { 
					$=thisData
				}
				//gratis nulls
				else if(option.g) { 
					$=null
				}
			}
		}
		else {
			//make sure we have a foundation to build off of
			//if we are nothing or a key name is specified but we're an array
			if (thisPath[0].constructor === String && ($ === undefined || $ === null || $.constructor !== Object)){
				if ($ !== undefined && option.G) {
					printErr("Guarding $["+thisPath[0]+"] from changing array to object, line: " + (i+1))
				}
				//Keep $["-"] from changing array into an object
				else if (thisPath[0] !== "-"){
					//initialize ourselves to be what's expected
					$={}
					thisNode=$			
				}
			}
			//or again if path is a number but $ is not any array
			else if (thisPath[0].constructor === Number && ($ === undefined || $ === null || $.constructor !== Array)){
				if ($ !== undefined && option.G) {
					printErr("Guarding $["+thisPath[0]+"] from changing object to array, line: " + (i+1))
				}
				else {
					//initialize ourselves to be what's expected
					$=[]
					thisNode=$			
				}
			}

			//walk down the path
			for(var j=0; j <= thisPath.length-1; j++){

				//if an array and $["-"] or $[-]  in the mix (although latter type should go)
				if (thisNode.constructor === Array && (thisPath[j].expression === "-" || thisPath[j] === "-")){
					var thisKeyName=thisNode.length
				}
				else {
					var thisKeyName=thisPath[j]
				}

				//if no data and not -g break early
				if((thisData === undefined && !option.g) || thisKeyName === undefined) { 
					break 
				}

				//if we are at the end (we step one above), make the assignment
				if(j === thisPath.length-1){
					if (thisNode[thisKeyName] !== undefined && option.G) {
						printErr("Guarding against re-assignment of '" + thisKeyName + "' to: " + JSON.stringify(thisData))
					}
					else { 
						//if this is not a path only and we have some data
						if(thisData !== undefined) { 
							thisNode[thisKeyName]=thisData
						}
						//otherwise if path only and -g (gratis nulls/guess)
						else if(option.g) { 
							thisNode[thisKeyName]=null
						}
					}
				}
				//otherwise go deeper
				else {					
					//if key/indice does NOT EXIST 
					if (!thisNode.hasOwnProperty(thisKeyName)) {
						//look ahead to the NEXT member type after this one
						if (thisPath[j+1].constructor === String){
							//initialize ourselves to be what's expected
							thisNode[thisKeyName]={}
						}
						//or again if we are nothing or a number is specified but we are an object
						else if (thisPath[j+1].constructor === Number){
							thisNode[thisKeyName]=[]
						}
						//else it could also be an expression				
					}
					//the key does exist, but before descent into, check that it is still the right type depending on NEXT types
					else {
						if (thisPath[j+1].constructor === String && (thisNode[thisKeyName] === undefined || thisNode[thisKeyName] === null || thisNode[thisKeyName].constructor !== Object)){
						//initialize ourselves to be what's expected
						thisNode[thisKeyName]={}
						}
						//or again if we are nothing or a number is specified but we are an object
						else if (thisPath[j+1].constructor === Number && (thisNode[thisKeyName] === undefined || thisNode[thisKeyName] === null || thisNode[thisKeyName].constructor !== Array)){
							thisNode[thisKeyName]=[]
						}
					}				
					//now descend
					thisNode=thisNode[thisKeyName]
				}
			}
		}				
	}	
	//JSON stringify and parse to fill in any undefined array holes with nulls
	return $ !== undefined ? JSON.parse(JSON.stringify($)) : []
}

function alterObject(obj,valueArg,fromArg,pathArg,option,JSONTextNumber,JSONPatchArg)
{	
	//if not -x or -X patch operations we are using individual -o -p -v -f values
	//validate those and build pathArgValidated
	if(!(option.x || option.X)) { 
		var opArg, pathArgValidated=[], fromArgValidated

		//-o - operation
		if(Object.keys(option.opArg)[0] !== undefined) { 
			opArg = Object.keys(option.opArg)[0]
		} 
		//-v or -V - value	
		if(valueArg !== undefined){
			//read data from file if -V
			if(option.V) {
				try { valueArg = readFile(valueArg) } 
				catch(error) { throw new Error(error) };
			}
			//if -s specified, treat contents of valueArg as JSON string , escape all special characters
			if(option.s) { 
				//replace and escape required characters
				valueArg = '"' + valueArg.replace(/[\u0000-\u001f\u007f|"|\\]/g, function(chr) { 
					switch(chr) { 
						case '"': return '\\"';
						case '\\': return "\\\\";
						case '\b': return "\\b"; 
						case '\f': return "\\f"; 
						case '\n': return "\\n"; 
						case '\r': return "\\r"; 
						case '\t': return "\\t";
						default: return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4)
						}
					}
				) + '"' 				
			} 
			//attempt to parse the supplied JSON
			try { valueArg = JSON.parse(valueArg) } 
			catch(e){ 
				if(option.c && option.H){printErr("Truncation help will be attmepted on value input (-v/-V)")}
				//try and rehab
				var tempJSONValueArray=rehabJSON(valueArg)

				//if we get nothing or more than one text back that's no good
				if (!tempJSONValueArray.length || tempJSONValueArray.length > 1 ){
					throw new Error("Multiple JSON texts are not allowed in as a value")
				}
				
				//parse only the first text
				try { valueArg = JSON.parse(tempJSONValueArray[0]) } 
				catch(error) {
					//a preview of 24 characters with ellipses
					printErr("Error in supplied JSON value (-v/-V): " + tempJSONValueArray[0].substring(0,24).replace(/[\n|\r]/g, '') + "\u2026");
					throw new Error(e)
				}
			}

		}
		//-f - from path
		//create fromArgValidated
		if(fromArg !== undefined) { 
			//this is a JSONPath, resolve
			if(fromArg === "$"){
				fromArgValidated = ""
			}
			//from is easy, it allows only one and it must exist
			//if JSONPath
			else if(fromArg[0] === "$"){
				//resolve the from path as JSON Pointer: from must always exist, no second pass needed
				try { 
					fromArgValidated = jsonPath(obj, objectifyExpressions([fromArg],null)[0].path, {resultType:"PATH_JSONPOINTER"}); 
				} 
				catch (error) { 
					throw new Error(error) 
				};
				
				if (!fromArgValidated.length){
					throw new Error("Unable to resolve from path: " + fromArg)
				}
				else if (fromArgValidated.length > 1){
					throw new RangeError("Error: \"From\" path returned multiple results: " + fromArg + "\n" + fromArgValidated.join("\n") )					
				}
				else {
					//we will only ever need one, so go back to a string
					fromArgValidated = fromArgValidated[0]
				}
			}
			else {
				fromArgValidated = fromArg
			}
		} 
		//-p - (path) can resolve to multiple paths
		//create pathArgValidated array
		if(pathArg !== undefined) { 
			//JSONPath $ is "" easy
			if(pathArg === "$"){ 
				pathArgValidated=[""]
			}
			//JSONPath of some sort, resolve
			else if(pathArg[0] === "$"){

				//expand any union at the end of the string
				try { pathArgValidated = objectifyExpressions([pathArg],{'expandTrailingUnion':true,'allowExpressions':true}) } catch(error) { throw new Error(error) }

				//take each path and verify it exists (remove, replace) or could exist (copy, move, add)
				pathArgValidated = pathArgValidated.map(function(p){
					//p is an object: {"path":[]}

					//if our path contains NO expressions, just absolute addresses: strings and numbers, return			
					//xp "expanded path" of p evaluated through jsonPath and returned as JSON Pointer
					try { var xp = jsonPath(obj, p.path, {resultType:"PATH_JSONPOINTER"}); } catch(error) { throw new Error(error) };

					//if it resolved it will have a length > 0, return "expanded path"
					if (xp.length) { 
						return xp 
					}
					//else if we get nothing AND it is remove, replace, or text return nothing - it should have existed!
					else if (option.opArg.remove || option.opArg.replace || option.opArg.test) {

						//gracefully ignore non-existant paths [?! - what]
						if (option.G){
							return "/"+p.path.map(function(p){ return p.toString().replace(/~/g,"~0").replace(/\//g,"~1")}).join('/')
						}
						return ""					
					}
					//pp "parent path"
					var pp = p.path.slice()
					//create pc "path child", while creating pp
					var pc = pp.pop()

					if(!pp.length && pc.expression === "-"){
						var possiblePaths='/-'
					}
					//if parent is beyond root
					else if(pp.length){
						//ppv "parent path verfied"
						var ppv = jsonPath(obj, pp, {resultType:"PATH_OBJECT"})
						//if we still get nothing, return nothing
						if (!ppv.length) {
							return ""
						}
						//re-attach our path child (pc) to 1 or more ppv
						var possiblePaths = ppv.map(function(ppve) {	
							//put child back on end
							ppve.path.push(pc.expression === "-" ? "-" : pc)								
							//test the child path to be either: ["key"] ['key'] .key (even though it should be normalized to ["key"]
							//allow [-] however any other path should have resolved, JSON Patch does not allow for indices beyond length
							if(pc !== null && (pc.constructor === String || pc.constructor === Array || pc.expression === "-")) { 
								//possiblePath verified element in json pointer
								var ppve_jp = "/" + ppve.path.map(function(p){ return p.toString().replace(/~/g,"~0").replace(/\//g,"~1")}).join('/')
								//return the JSONPath (ppve+pc) converted to JSON Pointer
								return ppve_jp
							}
							else {
								return ""							
							}
						})
					}
					//else this is root
					else {						
						//return answer regqrdless of types
						var possiblePaths = "/" + p.path.map(function(p){ return p.toString().replace(/~/g,"~0").replace(/\//g,"~1")}).join('/')
					}
					//return possible paths
					return possiblePaths
				})
				//flatten the array in case one entry became multiple
				.flat()
				//sort from shallowest to deepest
				.sortVarWidth().reverse()
				//remove empty lines
				.filter(function(p) {
					return p != null && p != '';
				})
				//de-dupe lines
				.filter(function(item, pos, ary) {
					return !pos || item != ary[pos - 1];
				});

				if (pathArgValidated.length > 1){
					if(option.opArg.move) {
						throw new Error("Move operation cannot have multiple destinations: " + pathArg + "\n" + pathArgValidated.join("\n"))
					}
				}
			}
			//single JSON Pointer
			else if(pathArg === "" || pathArg[0] === "/") { 
				pathArgValidated=[pathArg]
			}
			else {
				throw SyntaxError("Unrecognized query syntax: " + pathArg)
			}
		}		 
	}

	//Operations - JSON Merge Patch, merge, diff, and JSON Patch

	//-o merge - like JSON Merge Patch EXCEPT null values do NOT delete the key
	//-o mergepatch - JSON Merge Patch, merge plus delete keys set to null
	if(option.opArg.mergepatch || option.opArg.merge || option.opArg.merge0 || option.opArg.merge1 ){
		if(valueArg !== undefined && fromArgValidated !== undefined){
			throw new Error("Merge source ambiguous. Specify a value (-v/-V) or a path (-p), or neither.")
		}
		else if (valueArg === undefined && fromArgValidated === undefined) { 
			throw new SyntaxError("Merge source not given, specify a path (-p) or a JSON value (-v/-V).")
		}
		///3rd param, true enforces patch null remove behavior
		else { 
			//get the fromArg value
			if(fromArgValidated){				
				//since this is already normalized into JSON Pointer, pass to jsonPath as object				
				try { var rawVal = jsonPath(obj,objectifyExpressions([fromArgValidated])[0].path,null)[0] } catch(e){throw new Error(e)}
				valueArg=rawVal
				if(valueArg === undefined){ throw new Error("From path does not exist: " + fromArgValidated) }
			}
			else if(fromArgValidated === ""){
				//since this is already normalized into JSON Pointer, pass to jsonPath as object
				valueArg = jsonPath(obj,[],null)[0]
			}

			//no destination path mean it's applying to the whole document
			if(!pathArgValidated.length){
				obj = merge(obj,valueArg,(option.opArg.mergepatch ? true : false),(option.opArg.merge1 ? {"existingOnly":true} : (option.opArg.merge0 ? {"nonexistingOnly":true} : null )))
			}
			else{
				//if we have more than one path, run for each
				pathArgValidated.forEach(function(p){
					//get value of p within the obj
					try { var pval = jsonPath(obj,objectifyExpressions([p])[0].path,null)[0] } catch(e){throw new Error(e)}
					var mergedValue = merge(pval,valueArg,(option.opArg.mergepatch ? true : false),(option.opArg.merge1 ? {"existingOnly":true} : (option.opArg.merge0 ? {"nonexistingOnly":true} : null )))
					//need to replace this data within the main object
					try { obj = jsonpatch.apply_patch(obj,[{'op':"replace",'path':p,'value':mergedValue}]) } catch(e){throw new Error(e)}
				})						
			}
		}
	}
	//-o diff - creates merge patch diff (NOT the same as JSON Patch diff)
	else if(option.opArg.diff){
		//JSON Merge Patch
		if(valueArg !== undefined) { obj = diff(obj,valueArg,true) }
		else { throw new SyntaxError("No value specified!")}
	}
	//else try as a JSON Patch operation
	else{
		//build  opArray
		//-x is an inline JSON Patch statement
		//-X denotes the argument is a filespec to a JSONPath document
		if (option.x || option.X){
			if (option.X) {
				var JSONPatch=readFile(JSONPatchArg)
			} else {
				var JSONPatch=JSONPatchArg
			}
			
			try { var opArray = JSON.parse(JSONPatch) }
			catch(e){ 
				
				if(option.c && option.H){printErr("Truncation help will be attmepted on JSON Patch input")}
				//try and rehab it
				var tempJSONValueArray=rehabJSON(JSONPatch)

				//if we get nothing or more than one text back that's no good
				if (tempJSONValueArray.length > 1 ){
					throw new Error("Multiple JSON texts are not allowed for JSON Patch")
				} 
				else if (!tempJSONValueArray.length){
					throw new Error("No JSON supplied for JSON Patch!")
				}
			
				//parse only the first text
				try { opArray = JSON.parse(tempJSONValueArray[0]) } 
				catch(error) {
					//a preview of 24 characters with ellipses
					printErr("Error in supplied JSON Patch input: " + tempJSONValueArray[0].substring(0,24).replace(/[\n|\r]/g, '') + "\u2026");
					throw new Error(e)
				}
			}
		}
		//build as many opArray entries as there are validated path args
		else if (pathArgValidated.length){
			var opArray=[{}]
			//make opArray
			//if i is not defined in here it will be the i from the calling function and screw things up!
			var i
			for(var i=0; i < pathArgValidated.length; i++){
				opArray[i]={'op':opArg,'path':pathArgValidated[i],'from':fromArgValidated,'value':valueArg}
			}		
		}
		else {
			throw new Error("JSON Patch operation with no path provided!")
		}
		//try and apply the patch, throwing an error otherwise
		try { obj = jsonpatch.apply_patch(obj,opArray) } catch(e){throw new Error("JSON Text ("+JSONTextNumber+") "+e)}
	}
	return obj
}

// Rehab JSON: Remove JSON5 mutations, other minor issues, and end-truncation
// Orginally based on removeComments.js - James Padolsey - 2009 (https://j11y.io/javascript/removing-comments-in-javascript/)
// Loosely based on: http://www.weanswer.it/blog/optimize-css-javascript-remove-comments-php/
function rehabJSON(str) {
    str = str.split('');

	//a few of the modes we can be in
    var mode = {
        doubleQuote: false,
        singleQuote: false,
        inEscape: false,
        blockComment: false,
        blockCommentXML: false,
        lineComment: false
    };

	//possible objStack[i].state strings:
	//ARRAY_BEGIN
	//OBJECT_BEGIN
	//NEEDS_PROPNAME (object only)
	//NEEDS_NAMESEP (object only)
	//NEEDS_VALUE (object or array)
	//NEEDS_ENDER (object or array)
    
    //track where the array should start from as we create a new array of JSON texts
    var JSONTextStartIndex=0;
	//keeps track of where we are inside a JSON text, holds object: {"type":"", state:""}
	var objStack=[];
    //used as flag at end of for loop to make new JSON text
    var makeNewText=false
    //collect the supposed JSON texts
    var JSONTexts=[];        
    //where we last had a character of signifigance
    var lastCharIndex;    

    //process string
    for (var i=0, l=str.length; i < l; i++) {
		//inside a string '' or "" 
        if (mode.doubleQuote || mode.singleQuote) {   
        	if (mode.inEscape) { 
        		mode.inEscape = false
				//JSON5 null escape \0 has rule that digit cannot follow
				if (str[i] === '0' && (! /\d/.test(str[i+1]))) {
					if (option.c) { 
						printErr("Byte " + (i+1) + ": null notation \\0 (JSON5)" ) 
					}
					//just fix it by encoding it in standard JSON as \u0000
					str[i] = 'u0000'
				}
				//\v JSON5 vertical tab
				else if (str[i] === 'v') {					
					if (option.c) {	
						printErr("Byte " + (i+1) + ": vertical tab \\v (JSON5)" ) 
					 }
					//this is the ASCII value
					str[i] = 'u000b'
				}
				//JSON5 \xHH hex escape
				else if (str[i] === 'x' && /\d|[A-Fa-f]/.test(str[i+1]) && /\d|[A-Fa-f]/.test(str[i+2])) {
					if (option.c) {	
						printErr("Byte " + (i+1) + ": hex notation \\x (JSON5)" )
					}
					//convert to \u00xx
					str[i] = 'u00'
					//continue AFTER current element plus the two letter array elements
					i=i+2
				}
				//JSON5 escaped CRLF newlines \\r\n in strings
				else if (str[i] === '\r' && str[i+1] === '\n') {
					if (option.c) {	
						printErr("Byte " + (i+1) + ": \\ escaped newlines (\\r\\n) (JSON5)" )
					}
					str[i]=''
					str[i+1]=''
					i=i+1
				}
				//JSON5 escaped newline \n \r or \u2028 \u2029
				else if (str[i] === '\n' || str[i] === '\r' || str[i] === '\u2028' || str[i] === '\u2029') {
					if (option.c) {	
						printErr("Byte " + (i+1) + ": \\ escaped newline in string (JSON5)")
					}
					//remove it
					str[i]=''
				}
        	}
			//" Double Quote END or ' Single Quote END 
            else if ((str[i] === '"' && mode.doubleQuote) || (str[i] === "'" && mode.singleQuote)) {
				if (mode.singleQuote) {
					mode.singleQuote = false;
					//convert ' BACK to "
					str[i]='"'				
				} 
				else {
					mode.doubleQuote = false;
				}

				//if we are NOT in an object/array, make a new JSON Text
				if(!objStack.length){
					makeNewText=true
				}
				//otherwise note this
				else {
					lastCharIndex = i
				}            
            }
			//" double in a Single Quoted string - convert to escaped \"
            else if (str[i] === '"' && mode.singleQuote) {
	            str[i] = '\\"'				
            }
            //ESCAPE \\
        	else if (str[i] === '\\' ) {
        		//set this for when go around once more
				mode.inEscape = true
				lastCharIndex = i

				//JSON5 allows escaped CRLF, remove escape now
				if (str[i+1] === '\n' || (str[i+1] === '\r' && str[i+2] === '\n')) {
					//remove \\ now
					str[i]=''
				}
				//JSON5 escaped single quote '
				else if (str[i+1] === '\''){
					//remove escape now, the ' will be converted to " next loop
					str[i]=''
				}
        	}
        	//literal tabs in strings is not JSON5 but makes sense with escaped newlines
        	else if (str[i] === '\t' ) {
        		if (option.c) {	
        			printErr("Byte " + (i+1) + ": literal tab character in string" )
        		}
        		str[i] = '';
        	}
        	//if there is an unescaped newline in a string that's usually truncation
        	else if (str[i] === '\n') {
				if (option.c) {	
					printErr("Byte " + (i+1) + ": literal newline in quotes" )
				}
				 
				//-w will treat this as hard wrapped text
				if(option.w){
					if (option.c){
						printErr("Ignoring newline (-w)")
					}				
					str[i]='';
				}
				//-H help truncation
				else if(option.H) {
					if (option.c){
						printErr("Truncation help for JSON Text (" + (JSONTexts.length+1) +"), bytes: " + (JSONTextStartIndex+1) + "-" + (i+1))
					}
					//clear \n
					str[i]=''	

					//reset states					
					mode.singleQuote=false
					mode.doubleQuote=false

					if (objStack.length){
						//work through objStack
						var a;
						for(a=0; a < objStack.length; a++){						
							if(objStack[a].type === "Object"){		
								if(objStack[a].state === "NEEDS_NAMESEP"){
									if(option.c){
										if(a === 0){
											printErr("Truncation help after byte "+(i)+", open string, missing separator, value, object end: \":null}" )
										}
										else {
											printErr("Truncation help after byte "+(i)+", missing separator, value, object end: :null}")
										}
									}
									str[i]+=(a === 0 ? "\"" : "" )+":null}"
								}
								else if(objStack[a].state === "NEEDS_ENDER"){
									if(option.c){
										if(a === 0){
											printErr("Truncation help after byte "+(i)+", open string and object end: \"}" )
										}
										else {
											printErr("Truncation help after byte "+(i)+", object end: }")
										}
									}
									str[i]+=(a === 0 ? "\"" : "" )+"}"
								}	
							}
							else if(objStack[a].type === "Array"){
								if(objStack[a].state === "NEEDS_ENDER"){
									if(option.c){
										if(a === 0){
											printErr("Truncation help after byte "+(i)+", open string and array end: \"]")
										}
										else {
											printErr("Truncation help after byte "+(i)+", array end: ]")
										}
									}
									str[i]+=(a === 0 ? "\"" : "" )+"]"
								}
							}
						}
						//clear the stack
						objStack=[]					
					}
					else {
						if(option.c){
							printErr("Truncation help after byte "+(i)+", open string" )
						}
						str[i]+="\""
					}
					makeNewText = true
					
				}
			 	else {
				 	makeNewText = true
			 	}
        	}
        }
  		//in a line comment ; -- // # *** 
        else if (mode.lineComment) {
        	//end of the line, include JSON 5 U+2028 and U+2029, line and paragraph seperators
            if (str[i] === '\n' || str[i] === '\r' || str[i] === '\u2028' || str[i] === '\u2029') {
                mode.lineComment = false;
            }
            //remove the comment character
	        str[i] = '';                    
        }
 		//in /* */ block comment
        else if (mode.blockComment) {
        	// block comment */ over
            if (str[i] === '*' && str[i+1] === '/') {
				//remove both characters
				str[i] = '';
                str[i+1] = '';
                i=i+1
                mode.blockComment = false;
            } else {
				//remove character
				str[i] = '';
            }
        }
		//in XML block comment
        else if (mode.blockCommentXML) {
			// --> is over
            if (str[i] === '-' && str[i+1] === '-' && str[i+2] === '>') {
                str[i] = ''; str[i+1] = ''; str[i+2] = '';
                i=i+2
                mode.blockCommentXML = false;
            } 
            else {
            	str[i] = '';
            }
        }
 		//WHITESPACE - \s matches all Unicode Zs spaces, except BOM 0xfefe (JSON5)
 		else if(/[\s\ufefe]/.test(str[i])){

	 		//JSON5 allows additional white space chars - https://www.compart.com/en/unicode/category/Zs
			if(option.c && ! /[ \n\r\t]/g.test(str[i])){
        		if (option.c) {	
        			printErr("Byte " + (i+1) + ": additional whitespace character +(" + JSON.stringify(str[i],null,0) + ") (JSON5)")
        		}
			}
			//NORMALIZE whitespace to space or \n
			//newline like characters
			if (/[\f\r\v\u2028\u2029]/g.test(str[i])) {
				//if CRLF
				if (str[i] === '\r' && str[i+1] === '\n'){
					//move ahead to \n
					i=i+1
				}
				else {
					str[i]='\n'				
				}
			}
			//other space-like characters
			else if(/[^ \n]/g.test(str[i])) {
				str[i] = ' '		
			}
			
			//IGNORE normalized WS if NOTHING else has been processed
			if (lastCharIndex === undefined) {
				JSONTextStartIndex=i+1
				continue;
			}	
			
			//Make NEW JSON text if we are NOT in an object/array AND have processed something (not validating numbers) OR we are at the end
			if ((! objStack.length && lastCharIndex !== undefined) || (i === l-1)) {
				makeNewText = true
			}
		}
 		// JSON " quote or JSON5 ' quote
 		else if (str[i] === '"' || str[i] === "'") {

			if (str[i] === '"'){
				//set the quote mode 
				mode.doubleQuote = true;
			}
			else {
				mode.singleQuote = true;
				//convert back to JSON standard double quote
				str[i] = '"'

				if (option.c) {	
					printErr("Byte " + (i+1) + ": single quoted string (JSON5)") 
				}
			}
			if(objStack.length){
				//set state depending on current context
				if(objStack.length && objStack[0].type === "Object") {
					if(objStack[0].state === "OBJECT_BEGIN" || objStack[0].state === "NEEDS_PROPNAME") {
						//set for what we will need once OUT of the string, if something goes wrong in string it is handled there
						objStack[0].state = "NEEDS_NAMESEP"
					}
					else if(objStack[0].state === "NEEDS_VALUE") {
						//could be , or }
						objStack[0].state = "NEEDS_ENDER"
					}
				}
				else if(objStack.length &&  objStack[0].type === "Array") {
					if(objStack[0].state === "ARRAY_BEGIN" || objStack[0].state === "NEEDS_VALUE") {
						//could be a comma could be , or }
						objStack[0].state = "NEEDS_ENDER"
					}
				}
			}					
			lastCharIndex = i
		}
		//: key value separator
 		else if (str[i] === ':') {
 			//now we need a JSON value
			if(objStack.length && objStack[0].type === "Object" && objStack[0].state === "NEEDS_NAMESEP") {
				objStack[0].state = "NEEDS_VALUE"
			}

			lastCharIndex = i
		}
		//beginning of object
 		else if (str[i] === '{') {		

			//Detect Truncation
			//if -D AND we are in an object or array AND last character is \n (no indent) AND unexpected
			if(option.D && objStack.length && (str[i-1]==='\n' || (objStack[0].state !== "NEEDS_VALUE" && objStack[0].state !== "ARRAY_BEGIN"))){				
				//rewind
				i=i-1
				if (option.c){
					printErr("Byte " + (i+1) + ": Truncation Detected")
				}
				//make new text at previous mark
				makeNewText=true
			}
			else {
				//set state depending on current context
				if(objStack.length && objStack[0].type === "Object" && objStack[0].state === "NEEDS_VALUE") {
					objStack[0].state = "NEEDS_ENDER"
				}
				else if(objStack.length && objStack[0].type === "Array") {
					if(objStack[0].state === "ARRAY_BEGIN" || objStack[0].state === "NEEDS_VALUE") {
						//could be a comma could be , or }
						objStack[0].state = "NEEDS_ENDER"
					}
				}		
		
				objStack.unshift({"type":"Object","state":"OBJECT_BEGIN"})
		
				lastCharIndex = i			
			}
		}
		//beginning of array
 		else if (str[i] === '[') {
			//Detect Truncation
			//if -D AND we are in an object or array AND last character is \n (no indent) AND unexpected
			if(option.D && objStack.length && (str[i-1]==='\n' || (objStack[0].state !== "NEEDS_VALUE" && objStack[0].state !== "ARRAY_BEGIN"))){
				//rewind
				i=i-1
				if (option.c){
					printErr("Byte " + (i+1) + ": Truncation Detected")
				}
				//make new text at previous mark
				makeNewText=true
			}
			else {
				//set state depending on current context
				if(objStack.length && objStack[0].type === "Object" && objStack[0].state === "NEEDS_VALUE") {
					objStack[0].state = "NEEDS_ENDER"
				}
				else if(objStack.length &&  objStack[0].type === "Array") {
					if(objStack[0].state === "ARRAY_BEGIN" || objStack[0].state === "NEEDS_VALUE") {
						//could be a comma could be , or }
						objStack[0].state = "NEEDS_ENDER"
					}
				}		

				objStack.unshift({"type":"Array","state":"ARRAY_BEGIN"})
			
				lastCharIndex = i
			}

		}
		//end of object
 		else if (str[i] === '}') {
 			//remove JSON5 bad habits
 			if (str[lastCharIndex] === ',') {
 				if(option.c){
 					printErr("Byte " + (lastCharIndex-1) + ": trailing comma (JSON5)") 
 				}
 				//just blank it out
 				str[lastCharIndex]=''
 			}
 			//shift this OFF the stack
 			objStack.shift()

			//if we are no longer in object/array then make new text
			if(!objStack.length){
				makeNewText=true
			}			
			//still in some superceding object/array, state should still be valid move on
			else {
				lastCharIndex = i;
			}
		}
		//end of array
 		else if (str[i] === ']') {
 			//go back and remove trailing command
 			if (str[lastCharIndex] === ',') {
 				if(option.c){
 					printErr("Byte " + (lastCharIndex-1) + ": trailing comma (JSON5)") 
 				}
 				//just blank it out
 				str[lastCharIndex]=''
 			}

 			//shift this OFF the stack
 			objStack.shift()
 			
			//if we are no longer in object/array then make new text
			if(!objStack.length){
				makeNewText=true
			}
			else {
				lastCharIndex = i;
			}
		}
		//end of key/val pair or array element
 		else if (str[i] === ',') {
			lastCharIndex = i;
			
			//set state depending on context
			if(objStack.length && objStack[0].type === "Object" && objStack[0].state === "NEEDS_ENDER") {
				objStack[0].state = "NEEDS_PROPNAME"
			}
			else if(objStack.length && objStack[0].type === "Array") {
				if(objStack[0].state === "NEEDS_ENDER") {
					//could be a comma could be , or }
					objStack[0].state = "NEEDS_VALUE"
				}
			}
		}
		//true, false, or null
		else if ((str[i] === 'n' && str[i+1] === 'u' && str[i+2] === 'l' && str[i+3] === 'l') || (str[i] === 't' && str[i+1] === 'r' && str[i+2] === 'u' && str[i+3] === 'e') || (str[i] === 'f' && str[i+1] === 'a' && str[i+2] === 'l' && str[i+3] === 's' ||  str[i+4] === 'e')){		
			//set state depending on current context
			if(objStack.length && objStack[0].type === "Object" && objStack[0].state === "NEEDS_VALUE") {
				objStack[0].state = "NEEDS_ENDER"
			}
			else if(objStack.length && objStack[0].type === "Array") {
				if(objStack[0].state === "ARRAY_BEGIN" || objStack[0].state === "NEEDS_VALUE") {
					//could be a comma could be , or }
					objStack[0].state = "NEEDS_ENDER"
				}
			}		
			//finger out which on we are and move forward
			var candidate = str.slice(i,i+5).join('')
			
			if (candidate.slice(i,i+4) === "true" || candidate.slice(i,i+4) === "true"){
				lastCharIndex = i+4
			}
			if (candidate.slice(i,i+5) === "false"){
				lastCharIndex = i+5
			}
		}
		//JSON5 + sign
		else if (str[i] === '+' && (/\d/.test(str[i+1]) || str[i+1] === '.')) {
			if (option.c) {	
				printErr("Byte " + (i+1) + ": explicit plus + for value (JSON5)") 
			}

			//set state depending on current context
			if(objStack.length && objStack[0].type === "Object" && objStack[0].state === "NEEDS_VALUE") {
				objStack[0].state = "NEEDS_ENDER"
			}
			else if(objStack.length && objStack[0].type === "Array") {
				if(objStack[0].state === "ARRAY_BEGIN" || objStack[0].state === "NEEDS_VALUE") {
					//could be a comma could be , or }
					objStack[0].state = "NEEDS_ENDER"
				}
			}
			str[i] = '' 
		}
		//JSON5 . ensure preceding digit
		else if (str[i] === '.' && ! /\d/.test(str[i-1])) {
			if (option.c) {	
				printErr("Byte " + (i+1) + ": decimal point wihtout preceding digit (JSON5)") 
			}

			//set state depending on current context
			if(objStack.length && objStack[0].type === "Object" && objStack[0].state === "NEEDS_VALUE") {
				objStack[0].state = "NEEDS_ENDER"
			}
			else if(objStack.length && objStack[0].type === "Array") {
				if(objStack[0].state === "ARRAY_BEGIN" || objStack[0].state === "NEEDS_VALUE") {
					//could be a comma could be , or }
					objStack[0].state = "NEEDS_ENDER"
				}
			}
			//change from .x to 0.x
			str[i] = '0.'
			lastCharIndex = i
		}
		//JSON5 . remove trailing . with no digit
		else if (str[i] === '.' && ! /\d/.test(str[i+1])) {
			if (option.c) {	
				printErr("Byte " + (i+1) + ": trailing decimal lacking mantissa (JSON5)") 
			}
			str[i] = '' 
		}
		//JSON5 NaN as a value in objects, arrays, and standalone: convert to null
		else if ((str[i] === 'N' && str[i+1] === 'a' && str[i+2] === 'N') && (! objStack.length || (objStack[0].type === "Object" && str[lastCharIndex] !== '{' && str[lastCharIndex] !== ',' ) || objStack[0].type === "Array")) {
			if(option.c){
				printErr("Byte " + (i+1) + ": NaN for value (JSON5)") 
			}
			
			if(option['8']){
				str[i]='"'
				str[i+1]='NaN'
				str[i+2]='"'
				//advance
				i=i+2				
			}
			else {
				str[i]=''
				str[i+1]=''
				str[i+2]='null'
				//advance
				i=i+2			
			}

			lastCharIndex = i;
		}	
		//JSON5 +/-Infinity (As a value only only)
		else if ((str[i] === '-' || str[i] === '+') && str[i+1] === 'I' && str[i+2] === 'n' && str[i+3] === 'f' && str[i+4] === 'i' && str[i+5] === 'n' && str[i+6] === 'i' && str[i+7] === 't' && str[i+8] === 'y') {

			//ensure it is in an array or as an object value only
			if(! objStack.length || (objStack[0].type === "Object" && str[lastCharIndex] !== '{' && str[lastCharIndex] !== ',' ) || objStack[0].type === "Array") {
				if(option.c){
					printErr("Byte " + (i+1) + ": "+str[i]+"Infinity as value (JSON5)") 
				}				

				//convert to string
				if(option.I) {
					str[i+6]='"'
					str[i+7]=str[i] + 'Infinity'
					str[i+8]='"'
				} 
				else {
					str[i+6]=''
					str[i+7]=''
					str[i+8]='null'				
				}
				//blank out the rest
				str[i]=''
				str[i+1]=''
				str[i+2]=''
				str[i+3]=''
				str[i+4]=''
				str[i+5]=''
				//just before the change
				i=i+5
			}

		}
		//JSON5 Infinity - As both key name and value in objects and arrays
		else if (str[i] === 'I' && str[i+1] === 'n' && str[i+2] === 'f' && str[i+3] === 'i' && str[i+4] === 'n' && str[i+5] === 'i' && str[i+6] === 't' && str[i+7] === 'y') {
			if(option.c){
				printErr("Byte " + (i+1) + ": Infinity as value (JSON5)") 
			}
			str[i]=''
			str[i+1]=''
			str[i+2]=''
			str[i+3]=''
			str[i+4]=''
			
			if(option.I) {
				str[i+5]='"'
				str[i+6]='Infinity'
				str[i+7]='"'
			} 
			else {
				str[i+5]=''
				str[i+6]=''
				str[i+7]='null'				
			}
			//just before the new quote (in case of concat)
			i=i+4
		}
		//JSON5 0x hex numbers in arrays and object and at beginning of this string
		else if(str[i] === "0" && str[i+1] === "x" && (! objStack.length || objStack[0].type === "Array" || (objStack[0].type === "Object" && str[lastCharIndex] === ':'))) {
			//negative?
			if(str[i-1] === '-'){
				//back it up
				var hexIndexBegin=i-1
			} 
			else {
				var hexIndexBegin=i
			}
			if(option.c){
				printErr("Byte " + (hexIndexBegin-1) + ": 0x hex value (JSON5)")
			}
			//move i ahead, then loop until non-hex character or , ] }  comma, right bracket, right curly, whitespace
			for (i=i+2;i < l; i++) {
				if (! /[0-9A-Fa-f]/.test(str[i]) || /\s/.test(str[i]) || str[i] === ',' || str[i] === ']' || str[i] === '}' ||  str[i] === ' ' || str[i] === '\t' || str[i] === '\r' || str[i] === '\n' || str[i] === ':' || str[i] === '\ufefe' ) {
					//backup
					i=i-1
					break
				}				
			}

			var hexIndexEnd=i
			//make string bounded by indexes
			var hexString=str.slice(hexIndexBegin,hexIndexEnd+1).join('')
			var hexToDecimalValue=eval(hexString);
			//put the decimal value at the end of the range
			str[hexIndexEnd]=hexToDecimalValue

			//blank out all the data
			for (var o=hexIndexBegin; o < hexIndexEnd; o++){
				str[o]=''
			}
			//set state depending on current context
			if(objStack.length && objStack[0].type === "Object" && objStack[0].state === "NEEDS_VALUE") {
				objStack[0].state = "NEEDS_ENDER"
			}
			else if(objStack.length && objStack[0].type === "Array") {
				if(objStack[0].state === "ARRAY_BEGIN" || objStack[0].state === "NEEDS_VALUE") {
					//could be a comma could be , or }
					objStack[0].state = "NEEDS_ENDER"
				}
			}
			lastCharIndex = i
		}
		//- sign OR a Number
		else if (str[i] === '-' || /\d/.test(str[i])) {
			//set state depending on current context
			if(objStack.length && objStack[0].type === "Object" && objStack[0].state === "NEEDS_VALUE") {
				objStack[0].state = "NEEDS_ENDER"
			}
			else if(objStack.length && objStack[0].type === "Array") {
				if(objStack[0].state === "ARRAY_BEGIN" || objStack[0].state === "NEEDS_VALUE") {
					//could be a comma could be , or }
					objStack[0].state = "NEEDS_ENDER"
				}
			}
			//only if a number the lastCharIndex			
			if(/\d/.test(str[i])){
				lastCharIndex = i
			}
		}
		//JSON5 unquoted key name, comes after a { or , inside an object
		else if(/[$_A-Za-z]/.test(str[i]) && objStack.length && objStack[0].type === "Object" && (str[lastCharIndex] === '{' || str[lastCharIndex] === ',') ) {
			//this should loop forward until whitespace or : and quote whatever it finds
			if(option.c){ 
				printErr("Byte " + (i+1) + ": unquoted object key name (JSON5)")
			}
			//put a quote before this character
			str[i]="\"" + str[i]
			
			//loop forward until a ws or :
			//' ' || '\t' || '\r' || '\n' || '\u2028' || '\u2029' || ':'
			//move i ahead one until whitespace
			for (i=i+1;i<str.length; i++) {
				//until some valid chars come along
				if (/[^$_A-Za-z0-9]/.test(str[i])) {
					//back up
					i=i-1
					break
				}				
			}
			
			str[i] = str[i] + "\""
			//this is multi-character but nothing tests for "
			lastCharIndex = i
			//set our object stack
			if(objStack.length){
				//set state depending on current context
				if(objStack.length && objStack[0].type === "Object") {
					if(objStack[0].state === "OBJECT_BEGIN" || objStack[0].state === "NEEDS_PROPNAME") {
						//set for what we will need once OUT of the string, if something goes wrong in string it is handled there
						objStack[0].state = "NEEDS_NAMESEP"
					}
					else if(objStack[0].state === "NEEDS_VALUE") {
						//could be , or }
						objStack[0].state = "NEEDS_ENDER"
					}
				}
				else if(objStack.length &&  objStack[0].type === "Array") {
					if(objStack[0].state === "ARRAY_BEGIN" || objStack[0].state === "NEEDS_VALUE") {
						//could be a comma could be , or }
						objStack[0].state = "NEEDS_ENDER"
					}
				}
			}
		}
		//JSON5 COMMENTS
 		// // or /* style comment 
        else if (str[i] === '/' && str[i+1] === '*') {
			if(option.c){ 
				printErr("Byte " + (i+1) + ": /* block comment (JSON5)")
			}
			str[i] = '';
			mode.blockComment = true;
		}
        else if (str[i] === '/' && str[i+1] === '/') {
			if(option.c){ 
				printErr("Byte " + (i+1) + ": // line comment (JSON5)")
			}			
			str[i] = '';
			mode.lineComment = true;
		}
		//MISC COMMENTS
 		// -- comment
        else if (str[i] === '-' && str[i+1] === '-') {
			if(option.c){ 
				printErr("Byte " + (i+1) + ": -- line comment")
			}
			str[i] = '';
			mode.lineComment = true;
        }
 		// <!-- XML block comment
        else if (str[i] === '<' && str[i+1] === '!' && str[i+2] === '-' && str[i+3] === '-') {
			if(option.c){ 
				printErr("Byte " + (i+1) + ": <!-- block comment")
			}
			str[i] = '';
			mode.blockCommentXML = true;
        }
 		// *** comment from macOS ionodecache.json
        else if (str[i] === '*' && str[i+1] === '*' && str[i+2] === '*') {
			if(option.c){ 
				printErr("Byte " + (i+1) + ": *** line comment")
			}
			str[i] = '';
			mode.lineComment = true;
        }
		// # shell style comments
		else if (str[i] === '#') {
			if(option.c){ 
				printErr("Byte " + (i+1) + ": # line comment")
			}
			str[i] = '';
			mode.lineComment = true;
		}
		// ; asm style comments
		else if (str[i] === ';') {
			if(option.c){ 
				printErr("Byte " + (i+1) + ": ; line comment")
			}
			str[i] = '';
			mode.lineComment = true;
		}
		//some other data, set lastCharIndex
		else {
			lastCharIndex = i
		}
		//end of for loop for str
		//make new JSON text if we need to...
		if(makeNewText){

			var tempString=''
			//if we are STILL in an obj/arr and -H see if we can help
			if(objStack.length && option.H) {
				if (option.c){
					printErr("Truncation help for JSON Text (" + (JSONTexts.length+1) +"), bytes: " + (JSONTextStartIndex+1) + "-" + (i+1))
				}	
				//work through objStack
				var a;
				for(a=0; a < objStack.length; a++){
					if(objStack[a].type === "Object"){
						if(objStack[a].state === "NEEDS_ENDER" || objStack[a].state === "OBJECT_BEGIN"){
							if(option.c){printErr("Truncation help after byte "+(i+1)+", object end: }")}
							tempString+="}"
						}
						else if(objStack[a].state === "NEEDS_PROPNAME"){
							if(option.c){printErr("Truncation help after byte "+(i+1)+", open string, missing value and object end: \"\":null}")}
							tempString+="\"\":null}"
						}
						else if(objStack[a].state === "NEEDS_VALUE"){
							if(option.c){printErr("Truncation help after byte "+(i+1)+", missing value and object end: null}")}
							tempString+="null}"
						}
						else if(objStack[a].state === "NEEDS_NAMESEP"){
							if(option.c){printErr("Truncation help after byte "+(i+1)+", missing separator,value, and object end: :null}")}
							tempString+=":null}"
						}
					}
					else if(objStack[a].type === "Array"){
						if(objStack[a].state === "NEEDS_ENDER" || objStack[a].state === "ARRAY_BEGIN"){
							if(option.c){printErr("Truncation help after byte "+(i+1)+", array end: ]")}
							tempString+="]"
						}
						else if(objStack[a].state === "NEEDS_VALUE"){
							if(option.c){printErr("Truncation help after byte "+(i+1)+", missing value and array end: null]")}
							tempString+="null]"
						}
					}
				}
			}
			//add to the new array
			JSONTexts[JSONTexts.length]=str.slice(JSONTextStartIndex,i+1).join('')+tempString
			
			if(option.c && JSONTexts.length === 1){ 
				//note this if we end up with more than 1 text
				var JSONTextStartIndex_1=JSONTextStartIndex
				var JSONTextEndIndex_1=i
			}
			//if -c comment on the multiple texts
			if(option.c && JSONTexts.length > 1){ 
				//if we are #2 then go ahead and comment on #1
				if(JSONTexts.length === 2){ 
					printErr("Bytes " + (JSONTextStartIndex_1+1) + "-" + (JSONTextEndIndex_1+1) + ": JSON Text (1)")
				}
				
				printErr("Bytes " + (JSONTextStartIndex+1) + "-" + (i+1) + ": JSON Text (" + (JSONTexts.length) +")")
			}

			//next text will start after now
			JSONTextStartIndex=(i+1)

			//RESET ALL
			lastCharIndex = undefined
			objStack=[]
			newLineCount=0
			makeNewText=false
			mode.singleQuote=false
			mode.doubleQuote=false
			mode.inEscape=false
			mode.blockComment=false
			mode.blockCommentXML=false
			mode.lineComment=false
		} 		
    }
	return JSONTexts
}
//******************//
//FUNCTION POLYFILLS//
//******************//

//jsc lacked printErr() in 10.4-10.7 - use debug, also use eval to avoid hoisting
if (typeof printErr === "undefined" ) { eval("function printErr(string) { debug(string) }") }


//*********//
//VARIABLES// 
//*********//

//initialize the option object
var option = {};
var maxSize={}
//print function fails after this (minus two in case of newline insertions)
maxSize.print=715827882 - 2
//readFile fails after this
maxSize.file=2147483647

//ARGUMENTS

//arguments[0] - set to arg or "$" JSONPath root
var query = decodeURIComponent(escape(arguments[0])) || "$";
//arguments[1] - file arg, if empty will default to stdin
var fileArg = decodeURIComponent(escape(arguments[1])) || '/dev/stdin';
//arguments[2] - All options
var optionsArg = arguments[2] || '';
//read in all the options
for (var i=0; i < optionsArg.length; i++) {
	switch (optionsArg.charAt(i)) {
		case 'Q':option.Q=true;option.q=true; break;
		default:
			//use bracket in case number is used
			option[optionsArg.charAt(i)]=true
			break;			
	}
}
//arguments[3] - indent spaces (or char) default to 2
//var spaceArgString = (decodeURIComponent(escape(arguments[3])) !== undefined ? decodeURIComponent(escape(arguments[3])) : "2");
var spaceArgString = decodeURIComponent(escape(arguments[3])) || "2";
//stringify can take a string or a number, convert numeric strings to number type
var spaceArg=((/^\s*$/.test(spaceArgString) || isNaN(spaceArgString)) ? spaceArgString : Number(spaceArgString))
//also assign to property of option object
option.spaceArg = spaceArg

//arguments[4] - -v/-V VALUE arg for inserting a value
if((option.v || option.V)){ var valueArg = decodeURIComponent(escape(arguments[4])) }
else { var valueArg = undefined  }
//arguments[5] - -p PATH arg for JSON Patch
if (option.p) { var pathArg = decodeURIComponent(escape(arguments[5])) }
//arguments[6] - maximum Depth for output
option.maxDepth = arguments[6] !== '' && !isNaN(Number(arguments[6])) ? Number(arguments[6]) : -1;
//arguments[7] - assign to option.encoding if 1st character exists
if(arguments[7][0]){
	option.encoding={}
	option.encoding[decodeURIComponent(escape(arguments[7][0]))]=true
} 
else { 
	option.encoding=""
}
//arguments[8] - JSON Patch -o operation 
option.opArg={}
if (option.o) {option.opArg[decodeURIComponent(escape(arguments[8]))]=true}
//arguments[9] - JSON Patch -f FROM path
if (option.f) { var fromArg = decodeURIComponent(escape(arguments[9])) }
//arguments[10] - set the -x/-X JSONPatchArg Argument - inline data or filespec to JSON Patch array
var JSONPatchArg = decodeURIComponent(escape(arguments[10])) || '';
//arguments[11] - set the mode for -M multi-JSON output, defaults later to JSON-Seq (S)
var multiJSONArg = decodeURIComponent(escape(arguments[11])) || '';

//-k is -K just unquoted, keeps logic simple later
if(option.k) { option.K = true }
//by default indent -K/-k, set -i to true
if(option.K) { option.i = true }

//****//
//MAIN//
//***//

/* */ //get fileText
//use readFile() if we can
if (typeof readFile === "function" ) {
	//max file size is 2GiB (2147483647 bytes)
	//however print() maxes out at 715827882 bytes and stringify maxes out at 2GB
	try { 
		var fileText = readFile(fileArg) 
	} 
	catch(error) { 
		printErr("File error (note: jsc max size is " + maxSize.file + " bytes): " + error)
		quit()
	};
} 
//else read in line by line with readline()
else {
	//if we are attempting to use a merge file later show the workaround then quit
	if(option.V) {printErr("-V not available for this version of jsc\nUse -v \"$(< file)\" as a workaround"); quit();}
	//jsc lacked readFile in 10.4-10.10 but we can use readline
	//the shell must ensure empty lines are removed from the file or stream
	var fileText=''
	//readline will take in UTF-8 but pass to JS as if it was UTF-16, escape strips the leading 00 byte
	while ( line = decodeURIComponent(escape(this.readline())) ) { fileText += line + '\n'; }	
};

/* */ //turn fileText into JSONObjectArray
var JSONObjectArray=[];
//-S treat filetext as it were all a single JSON string
if(option.S) {

	//trims trailing \n from stdin
	if (fileArg === "/dev/stdin") { fileText = fileText.slice(0,-1) }

	//wraps the input in double quotes and escapes needed chars: " \ \b \f \n \r \t and 7f-ffff
	fileText='"' + fileText.replace(/[\u0000-\u001f\u007f-\uffff|"|\\]/g, function(chr) { switch(chr) { case '"': return '\\"';case '\\': return "\\\\";case '\b': return "\\b";case '\f': return "\\f";case '\n': return "\\n";case '\r': return "\\r";case '\t': return "\\t";default: return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4)}}) + '"'

	//try to parse the JSON document, quit if error
	try { JSONObjectArray[0] = JSON.parse(fileText) } catch(error) { printErr("JSON Input Data: " + error); quit() };	
}
//parse as JSON sequence if 1E found
else if (/\u001e/.test(fileText)) {
	//split on record Seperator
	var tempJSONArray=fileText.split("\u001e")

	//the first array member SHOULD be empty, warn otherwise and move on
	var tempJSONArray_preRS=tempJSONArray.shift()
	if(tempJSONArray_preRS) { 
		//this will exit immediately, not what we want
		//throw new Error("JSON Sequence text lacking leading Record Seperator (\u001e): " + tempJSONArray_preRS)
		printErr("Error: JSON Sequence text (0) lacking leading Record Seperator (\\u001e): " + tempJSONArray_preRS)
	}

	//loop through each possible text and attempt a parse
	for(var i=0,j=0;i < tempJSONArray.length ;i++){
		//ignore consecutive RS (per spec) and ignoring whitepace only between RS
		if (tempJSONArray[i] === '' || ! /\S/.test(tempJSONArray[i]) ) { 
			continue; 
		}

		//if we start with a "$" parse as JSONPath Object Literals
		if(/^\s*\$/.test(tempJSONArray[i])){ 
			//attempt to ingest the literals
			try { 
				JSONObjectArray[j] = ingestLiterals(tempJSONArray[i],option);
				var lastParse=1
			}
			catch (e) {
				printErr(e); 
				var lastParse=0
			}
			if(lastParse) {
				//advance counter j for JSONObjectArray
				j=j+1
			}
		} 
		else {
			//attempt parse of possible json texts in  array 
			try { 
				JSONObjectArray[j] = JSON.parse(tempJSONArray[i]) 
				var lastParse=1
			} 
			catch(error) {
				printErr("Error: Unable to parse JSON Sequence text (" + i + "): " + tempJSONArray[i]);
				var lastParse=0
			}
			//if last parse was a success AND is a Number, Boolean, or null AND DOES NOT have a space char at the end THEN it is NOT VALID per RFC spec
			if(lastParse && (JSONObjectArray[j] === null || JSONObjectArray[j].constructor === Number || JSONObjectArray[j].constructor === Boolean) && !/\s/.test(tempJSONArray[i][tempJSONArray[i].length-1])){
				//test for final character being a WS
				printErr("Error: JSON text sequence (" + (i+1) + ") lacking trailing whitespace: " + tempJSONArray[i]);
				//throw out the result, undefined will be skipped for output
				JSONObjectArray[j]=undefined
			}
			else if(lastParse) {
				//advance counter j for JSONObjectArray
				j=j+1
			}
		}	
	}
}

//Process JSONPath Object Literals (JPOL) if it begins with a $
//Note: JPOL is for expressing a SINGLE JSON node, NOT multiple nodes (separate JPOL with RS for multiple JSON texts)
else if(/^\s*\$/.test(fileText)){ 
	//attempt to ingest the literals
	try { JSONObjectArray[0] = ingestLiterals(fileText,option)} catch(e){printErr(e); quit() }
} 
//parse fileText to JSON Text(s) in JSONObjectArray
else {
	//try to parse the original JSON document into the first array slot, otherwise...
	try { JSONObjectArray[0] = JSON.parse(fileText) } 
	catch(error) { 
		var primaryParseErrorString=error
		if (option.c){ 
			printErr("Original error: " + error); 
		}
		//send string to rehab function
		var tempJSONArray=rehabJSON(fileText)
		//loop through each possible text and attempt a parse
		for(var i=0,j=0;i < tempJSONArray.length ;i++,j++) {
			//attempt parse of possible json texts in  array 
			try { JSONObjectArray[j] = JSON.parse(tempJSONArray[i]) } 
			catch(error) {
				//a preview of 24 characters with ellipses
				printErr("Error in JSON Text (" + (i+1) + "): " + tempJSONArray[i].substring(0,24).replace(/[\n|\r]/g, '') + "\u2026");
				printErr(error)
				//rewind j for JSONObjectArray 
				j=j-1
			}
		}				
	}
}	

//convert a multi-JSON sequence into a SINGLE array of parsed JSON texts
if (multiJSONArg == 'a') {
	var JSONObjectArray_temp=[]
	for(var i=0;i<=JSONObjectArray.length-1;i++){
		JSONObjectArray_temp[i]=JSONObjectArray[i]
	}
	JSONObjectArray=[]
	JSONObjectArray[0]=JSONObjectArray_temp
}

//QUERY collector
var resultObjects=[];


//LOOP through JSONObjectArray[i] - invoking alterObject for JSON Patch/JSON Merge Patch operations, then JSONPath query
for(var i=0; i < JSONObjectArray.length; i++){
	//if we have something in opArg...
	//invoke alterObject for JSON Patch, JSON Merge Patch and other operations
	if(option.x || option.X || (option.opArg.constructor === Object && Object.keys(option.opArg).length)){
		try { 
			JSONObjectArray[i] = alterObject(JSONObjectArray[i],valueArg,fromArg,pathArg,option,(i+1),JSONPatchArg) 
		} 
		catch(e){
			printErr(e); 
			continue;
		}
	}

	//if no query use the whole object for resultObjects
	if((query === "$" || query === "" ) && !option.j && !option.r) { 
		//put in array as if it were a query result though for consistent handling later
		resultObjects[i] = [ JSONObjectArray[i] ]
	}
	//parse query string into queryObject for jsonPath to act on JSONObjectArray resulting in resultObjects[i] entry
	else {
		//turn query string into the queryObject jsonPath is expecting, on error quit
		try { 
			var queryObject = objectifyExpressions([query],{'disallowData':true,'allowExpressions':true,'c':option.c})[0].path 
		} 
		catch(error){
			printErr(error); 
			//quit do not continue
			quit()
		}
		//invoke JSONPath on queryObject, on error quit
		try { 
			resultObjects[i] = jsonPath(JSONObjectArray[i], queryObject, (option.j || option.r) ? {'resultType': option.d ? "PATH_DOTTED" : option.r ? "PATH_JSONPOINTER" : "PATH", 'singleQuoteKeys':option.q,'P.escapeUnicode':(option.u ? true : false)} : null); 
		} 
		catch(error) { 
			printErr(error); 
			//quit do not continue
			quit()
		}
	}
	//now after getting the results, if the value is [] then we have NO results - even an empty array would return as [[]] not []
	if(! resultObjects[i].length) {
		printErr("No nodes matching " + query + (JSONObjectArray.length>1 ? " in JSON text " + (i+1) : ""))
		//undefined is unambiguos to whether results were returned
		resultObjects[i]=undefined
	}
}

/* */ //resultObjects final work (arrays and nesting)
//LOOP through resultObjects[i]
for(var i=0;i<=resultObjects.length-1;i++){
	if (resultObjects[i] === undefined) { continue; }
	//remove the outer array from resultObjects
	if (Array.isArray(resultObjects[i]) && resultObjects[i].length === 1 ){
		resultObjects[i]=resultObjects[i][0]
	}
	//-N reduce the nested arrays with one member
	if(option.N && resultObjects[i] !== null ) {
		//if we have an array and contain exactly 1 object we can reduce
		while(Array.isArray(resultObjects[i]) && resultObjects[i].length === 1 ){ 
			//if -a ("always array") and the next element is an object: break
			if ((! resultObjects[i] === null) && (option.a && resultObjects[i][0].constructor === Object)) { 
				break; 
			}
			//if the item is NOT an array (in a very double negative way): break
			if ( !resultObjects[i].some(function(val) { return (val != null)&&(typeof val === "object") })) { 
				//break; 
			};
			//remove a level of nesting
			resultObjects[i] = resultObjects[i][0]
		}
	}

	//if -a and item is NOT an array, make it one with our resultObjects
	if (option.a && !Array.isArray(resultObjects[i])) {
		resultObjects[i]=[resultObjects[i]]
	}

	//-t (text encoding option) is only for a SINGLE string, number, boolean or null value NOT Arrays or Object
	if (option.t && (resultObjects[i] === null || !(Array.isArray(resultObjects[i]) || resultObjects[i].constructor === Object)) ) { option.T=true } 

	/* */ //resultObjects length (quits now but needs to keep continue for loop later)

	//-l print length of array, object, string then quit
	if (option.l) { 
		//null -  null returns 0 (as do empty: arrays, objects and strings)
		if(resultObjects[i] === null) { 
			print("0") 
		}
		//number - return 1 
		else if (resultObjects[i].constructor === Number) { 
			//just counted number of all the digit characters
			print("1")
		}
		//boolean - count as 1 value
		else if (resultObjects[i].constructor === Boolean) { 
			print("1") 
		}
		//string - character count
		else if (resultObjects[i].constructor === String) { 
			print(resultObjects[i].length); 
		}
		//array - element count 
		else if (Array.isArray(resultObjects[i])) { 
			print(resultObjects[i].length); 
		}
		//object - key count
		else if (resultObjects[i].constructor === Object) { 
			print(Object.keys(resultObjects[i]).length); 
		}
		//don't need to do anything remaining in this loop
		continue
	}
	//sort all objects key/vals pairs alphabetically (arrays are NOT reordered)
	if(option.O){
		resultObjects[i] = sortObject(resultObjects[i])
	}
	//-F - for now a VERY superficial flatten
	if(option.F && Array.isArray(resultObjects[i])){
		resultObjects[i] = flatten(resultObjects[i])
	}
}

//if length only quit now, it has already been printed
if (option.l){
	quit();
}

//PRINT
/* */ //turn resultObjects into resultText

//-MA makes multi-text JSON results into a single JSON array
if (multiJSONArg == 'A') {
	var resultObjects_new=[[]]
	for(var i=0;i<=resultObjects.length-1;i++){
		resultObjects_new[0][i]=resultObjects[i]
	}
	resultObjects=resultObjects_new
}

//LOOP through resultObjects[i]
for(var i=0;i<=resultObjects.length-1;i++){
	if (resultObjects[i] === undefined) { continue; }
	//create resultText if a text output mode chosen (-T/-t -L -J/-j -R/-r )
	if ( option.T || option.L || option.J || option.R || option.j || option.r ) {
			//create a flat array of strings to process as text if required, -p paths are already how we want them
			if(!option.j && !option.r) {
				resultObjects[i]=renderObject(resultObjects[i],(!option.T ? (option.R ? "" : "$") : null),option)
			}
			//if -n 
			if(resultObjects[i] === null) {
				var resultText=(option.n ? "null" : undefined)
			}
			else if(Array.isArray(resultObjects[i])) {
				var resultText = resultObjects[i].join('\n')
			}
			else {
				var resultText = resultObjects[i].toString()
			}
	} 
	//else JSON stringify
	else { 
		//if we are specifiying -MN (NDJSON) then enforce spaceArg of 0
		if (multiJSONArg == 'N'){ spaceArg = 0 }
		try { 
			//-u escapes 7f-ffff otherwise just 7f
			//-/ will escape / with \/ (on spec if required)
			var resultText = JSON.stringify(resultObjects[i],null,spaceArg).replace((option.u ? /[\u007f-\uFFFF]/g : /[\u007f]/g), function(chr) { 
				return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4)
			}).replace((option['/'] ? /[\/]/g : undefined),"\\/")
		} 
		catch(error){
			printErr("JSON.stringify: " + error)
		}
	}

	//for JSON pointer output (-r or -R) combined with the -EW or -Ew option outputs URI fragment representations
	if ((option.encoding.w || option.encoding.W) && (option.r || option.R)){
		resultText = resultText.split("\n").map(function(a){return "#" + encodeURI(a)}).join("\n")
	}

	/* */ //PRINT RESULT
	//insert record separator before each record if NOT text output and IF specified OR and we have more than 1 to output
	if( ! option.T && (multiJSONArg == 'S' || (resultObjects.length > 1 && ! multiJSONArg))){ 
		var possibleRS="\u001e" 
	} 
	else {
		var possibleRS="" 
	}
	if (resultText === undefined) { continue }
	//print function fails after after 715827882 bytes
	else if (resultText.length > maxSize.print) { jscChunkPrint(possibleRS + resultText) }
	else { try { print(possibleRS + resultText) } catch(error){ printErr("print " + error) } }
}
EOT

#############
# VARIABLES #
#############

#help text in a single line
read -r -d '' helpText <<'EOT'
jpt (v1.0.4) - JSON Power Tool (https://github.com/brunerd/jpt)\n\nUsage:\njpt [options] [<query>] [<file>]\n\nArguments:\n\t[<query>] - JSONPath, JSON Pointer, or plutil-style keypath expression (optional), returns entire document otherwise.\n\t[<file>] - path to JSON file\n\nNotes:\n\tDefault output mode is JSON (RFC8259/STD90)\n\tMultiple JSON texts will be output as a JSON Text Sequence (RFC 7464) (use -M to change behavior and processing)\n\tjpt accepts input by file redirection, Unix pipe, here string, heredoc and via /dev/stdin (end with Control-D)\n\tjpt accepts JSON, JSON text Sequences, and non-JSON mutations such as JSON5, NDJSON and jpt's own JSONPath Object Literals\n\tJSON Text Sequences will be strictly parsed to RFC 7464 specs, non-JSON elements are only tolerated in single and concatenated JSON texts\n\tNon-JSON elements are corrected automatically, if possible, before parsing (use -c for comments via stderr with an exit status of 1)\n\t  JSON5 Rehabilitations (mostly):\n\t    Unquoted object keys and single quoted strings are converted to JSON strings\n\t    Additional Unicode whitespaces and paragraph separators are converted to normal spaces (0x20) and newlines (0x0A)\n\t    Trailing commas are removed from object and array elements\n\t    Explicit plus signs on numbers are removed, decimals without leading zeroes are restored\n\t    Multi-line strings with escaped line breaks are reverted to standard JSON strings\n\t      Literal tabs in strings are removed also\n\t    Escaped character conversions: \n\t\t  \\0 to null\n\t\t  \\v to '\\u000c'\n\t    JSON5 number type conversions: \n\t\t  NaN to null (use -8 to convert to "NaN" string)\n\t\t  Inifinity to null (use -I to convert to "Infinity" string, with sign if specified)\n\t    Single-line (//) and multi-line (/* */) style comments are removed\n\t\t  Additionally multi-line XML (<!-- -->) and single line Shell (#), ASM (;), and Lua (--) comments are removed\n\t\nGeneral Options:\n\t-h this help screen\n\nJSON Output Options:\n\t-i "<number/string>" indent number of spaces (0-10) or use a <string> for each level of indent\n\t-O Order property names in objects alphabetically\n\t-u Unicode escape (\\u) all characters above 0x7E\n\nAdvanced JSON Output Options:\n\t-a always output result in an array\n\t-c comment on corrections to non-standard JSON via stderr output (with exit status of 1)\n\t-F Flatten array output\n\t-I Convert JSON5 +/-Infinity value to a string with signedness (otherwise converts to null)\n\t-N Nested single element arrays are reduced\n\t-8 Convert JSON5 NaN to a string (otherwise converts to null)\n\t-/ Escape solidus / with a reverse solidus like \\/, useful for HTML with embedded JSON encoded HTML\n\nInput Options:\n\t-D Detect truncation within objects and arrays in concatenated JSON only\n\t-g path-only JSONPath Object Literals are assigned a value of null ("gratis nulls")\n\t-G Guard previously defined JSONPath Object Literals from being modified by new statements\n\t-H Help truncated JSON by closing up open strings, objects and arrays\n\t-S Treat input as a JSON string\n\nMultiple JSON Text Options:\n\t-M "<value>" - options for working with multiple JSON texts\n\t\tS - Output JSON Text Sequences strictly conforming to RFC 7464 (default)\n\t\tN - Output newline delimited JSON texts\n\t\tC - Output concatenated JSON texts\n\t\tA - Gather JSON texts into an array, post-query and post-patching\n\t\ta - Gather JSON texts into an array, pre-query and pre-patching \n\nAlternate Output Modes (non-JSON):\n\t-l output the length of the resulting array, object property count, or length of string\n\n\t-J JSONPath path(s) of the object returned by the query\n\t-j JSONPath path(s) matched by the query results\n\n\t-R JSON Pointer path(s) of the object returned by the query\n\t-r JSON Pointer path(s) matched by the query results\n\t\tSpecifiying -EW or -Ew encodes both -r and -R JSON Pointer paths in URI fragment style\n\n\t  -J and -R path output options:\n\t\t-C append the "constructor" type (Array, Object, String, Boolean, Number, or null)\n\t\t-K/-k print property (key) names and array indices only with no preceding path, default indent is 2\n\t\t\t-i "<value>" indent spaces (0-10) or character for each level of indent\n\n\t-L JSONPath Object Literal notation output of the resulting object\n\t\tJPOL Format: <JSONPath expression>=<JSON value>\n\t\t\t<JSONPath expression> is simply Javascript expression syntax with $ as the object name\n\t\t\t\tExample: $.key, $["key"], $['key'], or $[0]\n\t\t\t<JSON value> is any valid JSON value (plus single quoted strings)\n\t\t\t\tExample: 'string', "string", [], {}, 42, true, false, null\n\n\t  JSONPath output options for -L -J and -j:\n\t\t-d Use dot notation for object property names when possible, rather than bracket notation\n\t\t-q Use single quotes for bracketed property names, string values remain JSON double quoted\n\t\t-Q Use single quotes for BOTH bracketed property names AND string values (-L only)\n\t\t-u encode characters above 7E with \\u escape\n\n\t  Output limiting options for -L, -J, and -R:\n\t\t-P Only print Primitive data types (String, Boolean, Number, null) omitting Arrays and Objects\n\t\t-Z "<int>" Depth\n\t\t\tCombined with -L it will coalesce lower depth levels into a compound JSON object/array statement\n\t\t\tCombined with -P both -J and -R will return only purely primitive nodes at or below the Z level\n\n\t-T textual output of all data (omits property names and indices)\n\t  Options:\n\t\t-e Print escaped characters literally: \\b \\f \\n \\r \\t \\v and \\\\ (\\ escaped formats only)\n\t\t-i "<value>" indent spaces (0-10) or character string for each level of indent\n\t\t-n convert null value to string 'null' (pre-encoding)\n\n\t\t-E "<value>" encoding options for -T output:\n\n\t\t  Encodes string characters below 0x20 and above 0x7E with pass-through for all else:\n\t\t\tx \t"\\x" prefixed hexadecimal UTF-8 strings\n\t\t\tO \t"\\nnn" style octal for UTF-8 strings\n\t\t\t0 \t"\\0nnn" style octal for UTF-8 strings\n\t\t\tu \t"\\u" prefixed Unicode for UTF-16 strings\n\t\t\tU \t"\\U "prefixed Unicode Code Point strings\n\t\t\tE \t"\\u{...}" prefixed ES2016 Unicode Code Point strings\n\t\t\tW \t"%nn" Web encoded UTF-8 string using encodeURI (respects scheme and domain of URL)\n\t\t\tw \t"%nn" Web encoded UTF-8 string using encodeURIComponent (encodes all components URL)\n\n\t\t\t  -W encodes whitespace characters also\n\t\t\t  -A encodes ALL characters\n\t\t\n\t\t  Encodes both strings and numbers with pass-through for all else:\n\t\t\th \t"0x" prefixed lowercase hexadecimal, UTF-8 strings\n\t\t\tH \t"0x" prefixed uppercase hexadecimal, UTF-8 strings\n\t\t\to \t"0o" prefixed octal, UTF-8 strings\n\t\t\t6 \t"0b" prefixed binary, 16 bit _ spaced numbers and UTF-16 strings\n\t\t\tB \t"0b" prefixed binary, 8 bit _ spaced numbers and UTF-16 strings\n\t\t\tb \t"0b" prefixed binary, 8 bit _ spaced numbers and UTF-8 strings\n\n\t\t\t  -U whitespace is left untouched (not encoded)\n\nData Processing:\n\tjpt can apply JSON Patch (RFC 6902), JSON Merge Patch (RFC 7396), and other operations to JSON text(s)\n\n\tJSON Patch processing:\n\t\t-X "<filepath to JSON Patch>" a file path to a JSON Patch array (RFC 6902)\n\t\t-x "<inline JSON Patch>" inline JSON Patch text (RFC 6902)\n\t\t\n\tJSON Patch Example (from RFC 6902):\n\t\t [\n\t\t\t { "op": "test", "path": "/a/b/c", "value": "foo" },\n\t\t\t { "op": "remove", "path": "/a/b/c" },\n\t\t\t { "op": "add", "path": "/a/b/c", "value": [ "foo", "bar" ] },\n\t\t\t { "op": "replace", "path": "/a/b/c", "value": 42 },\n\t\t\t { "op": "move", "from": "/a/b/c", "path": "/a/b/d" },\n\t\t\t { "op": "copy", "from": "/a/b/d", "path": "/a/b/e" }\n\t\t]\n\n\tSingle operations for JSON Patch, JSON Merge Patch, and others can be crafted using -o plus -p (path) and possibly -f (from) or -v/-V (value)\n\n\t\t-o "<operation>":\n\t\t [JSON Patch Operations]\n\t\t  add\n\t\t\t-o add -p "<path>" -v "<value>"\n\t\t\t\tadd/replace value in object or insert value into array index (RFC 6902)\n\t\t  replace\n\t\t\t-o replace -p "<path>" -v "<value>"\n\t\t\t\treplace value of existing object property (key) or array index (RFC 6902)\n\t\t  remove\n\t\t\t-o remove -p "<path>"\n\t\t\t\tremove specified path from the document (RFC 6902)\n\t\t  move\n\t\t\t-o move -f "<from>" -p "<path>"\n\t\t\t\tmove a path to a new or existing path/node(RFC 6902)\n\t\t  copy\n\t\t\t-o copy -f "<from>" -p "<path>"\n\t\t\t\tcopy a path to a new or existing path/node (RFC 6902)\n\t\t  test\n\t\t\t-o test -p "<path>" -v "<value>"\n\t\t\t\ttest if a path matches a value exactly (RFC 6902), return 0 if true, 1 if false\n\n\t\t [Other Operations]\n\t\t  diff\n\t\t\t-o diff -v "<value>"\n\t\t\t\tGiven a value, compare with JSON text and produce a JSON Merge Patch (RFC 7396) document\n\t\t  mergepatch\n\t\t\t-o mergepatch (-v/-V "<value>" || -f "<path>") [-p <path>]\n\t\t\t\tJSON Merge Patch (RFC 7396) operation: null values delete target object property\n\t\t\t\tCan pull data from -v/-V "<value>" OR -f "<path>", can merge to specific -p "<path>" (JSONPaths allows multiple)\n\t\t  merge\n\t\t\t-o merge (-v/-V "<value>" || -f "<path>") [-p "<path>"]\n\t\t\t\tNon-RFC 7396 merging operation, object properties with null values are NOT removed\n\t\t\t\tCan pull data from -v/-V "<value>" or -f "<path>", can merge to specific -p "<path>" (JSONPaths allows multiple)\n\t\t  merge0\n\t\t\t-o merge0 (-v/-V "<value>" || -f "<path>") [-p "<path>"]\n\t\t\t\tMerge object properties that DO NOT intersect with source JSON\n\t\t\t\tCan pull data from -v/-V "<value>" or -f "<path>", can merge to specific -p "<path>" (JSONPaths allows multiple)\n\t\t  merge1\n\t\t\t-o merge1 (-v/-V "<value>" || -f "<path>") [-p "<path>"]\n\t\t\t\tMerge object properties that intersect with source JSON\n\t\t\t\tCan pull data from -v/-V "<value>" or -f "<path>", can merge to specific -p "<path>" (JSONPaths allows multiple)\n\t\t\t\t\n\t\t-p "<path>":\n\t\t\t-p "<path>" the target path expressed in JSON Pointer (RFC 6901) or JSONPath\n\n\t\t-f "<from path>":\n\t\t\tcopy and move require a JSON Pointer (RFC 6901) or JSONPath expression\n\n\t\t-v/-V "<value>":\n\t\t\t-v "<JSON value>" is a single JSON text\n\t\t\t-V "<filespec to JSON value>" is a file path to a single JSON text\n\t\t  Options for -v/-V:\n\t\t\t-s treat input as a string\n\t\t\t\t\nJSONPath Primer\n\t$\n\t\tthe root of the JSON document, ALL JSONPath QUERIES MUST BEGIN WITH $\n\t.key or ['key']\n\t\ta "child" operator for an object property named 'key' in a JSON object\n\t..key or ..['key']\n\t\tis a recursive operator that will find all properties named 'key' within the object\n\t['key name'] or ["key \ud83d\udd11"]\n\t\tproperty names with spaces or escaped values MUST use bracket notation\n\t.* or [*]\n\t\t* returns the values of all the keys within an object or all indices in an array\n\t[start:stop:step]\n\t\tslice operation for arrays, accepts pos/neg integers, script and filter expressions, or leave empty\n\t[?(@ >= 3 && @ <= 10 )] or [?(@.key == "string" || @['key2'] == "string2")] or the off-spec [?(@name =~ /key.*/)], etc...\n\t\tfilter expressions can return one or more matching objects within an array\n\t\t@ is the current object, dot and bracket notation can be used to query child nodes\n\t\tUse logical operators like: == (equal), != (not equal), > (greater than), < (less than), >= (greater or equal), <= (less or equal)\n\t\tMultiple criteria can be evaluated with && (AND) and || (OR). Regular expressions can also be used: '=~ /regexp/'\n\t\t@.length is the length of an array or string\n\t\t@name is the current property name (an off-spec but useful quirk of the original Goessner code)\n\t[(@.length/2)]\n\t\t"script expression", returns a single value, use as an array index selector that allow division\n\t\tNote: This will not make it into the IETF JSONPath spec\n\t[1] or [-1]\n\t\tarray index, integers only, positive starts at the beginning, negative references from the end \n\t["-"]\n\t\tThe nonexistent array member after the last array element\n\t\tUse with data alteration operations, will always be empty for queries of arrays\n\t\tAkin to /- in JSON Pointer, if used with an object simply looks for a key named "-"\n\t["a","b"]\n\t\tunion, a comma separated list of expressions values of multiple properties at the same level in an object\n\t\tUnions allow for: quoted property names (single or double), numbers, *, filter and script expressions, and slices\n\n\tFor more examples: https://github.com/brunerd/jsonpath\n\t\nJSON Pointer (RFC 6901) Primer\n\t""\t\tan empty string represents the JSON document\n\t/\t\tis the root or next child node with a property named "" an empty string (JSONPath $[""])\n\t/key\t\tproperty named key in an object\n\t/1\t\tproperty named 1 in an object or a numeric index in an array\n\t/-\t\tthe nonexistent array member after the last array element, use with data alteration operations\n\t~\t\tin a property name must be escaped as ~0\n\t/\t\tin a property name must be escaped as ~1\n\n\tExample: /JSON pointer/does/this/1/thing/well\n\nkeypath primer:\n\tThis arcane summoning hails from ye olde NextStep and still used by plutil\n\t\n\t.\t\ta period is used to delimit key names, \n\t\t\t\tliteral periods can be backslash (\\) escaped\n\tkey\t\tan object name or array element, there is no root character\n\t\t\t\t\t\t\t\t\n\tKeypath Example: this.is.1.ugly.key\\.path\n\n\tIn JSON Pointer: /this/is/1/ugly/key.path\n\tAnd in JSONPath: $.this.is[1].ugly.["key.path"]\n\n\tNote: If a keypath query begins with characters that collide with JSONPath ($), jq-style (. or [) or JSON Pointer (/) it will be evaluated as one of those.
EOT

## CHECK FOR JSC
#Apple changed jsc location in 10.15 to Helpers from Resources, make array of locations
locations=( "/System/Library/Frameworks/JavaScriptCore.framework/Versions/Current/Helpers/jsc"
"/System/Library/Frameworks/JavaScriptCore.framework/Versions/Current/Resources/jsc" )

#search the two mac locations
for loc in ${locations[@]}; do
	[ -x "${loc}" ] && jsc="${loc}" && break
done

#if no joy, try the search path
[ -z "${jsc}" ] && jsc=$(which jsc)

#if not, search in other possible locations
if [ -z "${jsc}" ]; then
	locations=( "/System/Library/Frameworks/JavaScriptCore.framework/Versions/Current"
	"/usr/bin/jsc" #ubuntu
	"/usr/libexec/webkit2gtk*" #centos
	)

	for loc in ${locations[@]}; do
		jsc=$(find -L "${loc}" -name 'jsc' -maxdepth 2 2>/dev/null)
		[ -n "${jsc}" ] && break
	done	
fi

#bail if no jsc found
[ -z "${jsc}" ] && echo "Unable to locate a jsc binary!" && exit 1

#if bash, unset these getopts variables each time
[ -n "$BASH_VERSION" ] && unset OPTIND OPTARG

while getopts ":8cKkDSQPAE:Ff:lNLOuo:i:aCIeHhdnqgGJzjsRrTtUWwZ:v:V:x:X:p:M:%/" option; do
	case "${option}" in

		#output modes are exclusive
		'J'|'L'|'R'|'t'|'j'|'l'|'r'|'t') [ -z "${outputOpt}" ] && outputOpt="${option}" ;;

		#operation
		'o')[ -z "${alterOp}" ] && { options+="${option}"; alterOp="${OPTARG}"; } ;;

		#path - JSONPath or JSON Pointer
		'p')[ -z "${pathArg}" ] && { options+="${option}"; pathArg="${OPTARG}"; } ;;

		#value - JSON value
		'v'|'V')[ -z "${valueArg}" ] && { options+="${option}"; valueArg="${OPTARG}"; } ;;

		#from path - JSONPath or JSON Pointer
		'f')[ -z "${fromArg}" ] && { options+="${option}"; fromArg="${OPTARG}"; } ;;

		#JSON Patch - JSON expression or filespec to JSON
		'x'|'X')[ -z "${JSONPatchArg}" ] && { options+="${option}"; JSONPatchArg="${OPTARG}"; } ;;

		#indent argument - can be number or string
		'i')options+="${option}"; spaceArg="${OPTARG}";;

		#multiple JSON texts (arguments: S=JSON-seq, N=NDJSON, C=cat-JSON, A=make Array After query and processing, a=make array Before)
		'M')options+="${option}"; multiOutArg="${OPTARG}";;

		#depth to descend into JSON output
		'Z')depthArg="${OPTARG}";;

		#text encoding options
		#convert % flag (old) to W (new)
		'E')[ -z "${encodingArg}" ] && encodingArg+="${OPTARG/\%/W}";;
		#nicely paginate with less
		'h')echo -e "${helpText}" | less; exit;;

		#do nothing for unknown options
		'?'):;;

		#all the other options
		*)options+="${option}";;
	esac
done

#add the single output mode to options now
options+="${outputOpt}"

#shift if we have args so $1 is still $1 after the options
[ $OPTIND -ge 2 ] && shift $((OPTIND-1))

#both of these are optional, if no query specified, output the JSON entire document(s), no fileArg invokes cat to wait for input in stdin
queryArg="${1}"
fileArg="${2}"

#allow for query to be optional, if valid file is specified use that
[ -f "${queryArg}" ] && [ -z "${fileArg}" ] && { fileArg="${queryArg}"; unset queryArg; }

########
# MAIN #
########

#can we read files in this version of jsc?
readFileSupport="$(${jsc} -e 'print(typeof readFile === "function")')"

#test specified file
if [ -n "${fileArg}" ]; then
	if [ "${fileArg}" != '/dev/stdin' ] && ! [ -f "${fileArg}" ]; then
		echo "--> File not found: ${fileArg}" >&2
		return 1
	elif ! [ -r "${fileArg}" ]; then
		echo "--> File not readable: ${fileArg}" >&2
		return 1
	fi

	#readFile maxes out at 2GB (jsc print has 720MB limit and stringify at 1GB)
	if [ "${readFileSupport}" = "true" ]; then
		#figure out which stat method works
		#mac/bsd
		if stat -f %z . &> /dev/null; then
			fileSize=$(stat -f %z "${fileArg}")
		#gnu/linux
		elif stat -c %s . &> /dev/null; then
			fileSize=$(stat -c %s "${fileArg}")
		elif stat --format %s . &> /dev/null; then
			fileSize=$(stat --format %s "${fileArg}")
		fi
			
		if [ "${fileSize}" -ge 2147483648 ]; then
			echo "--> File exceeds readFile() maximum size (2GiB)!" >&2
			return 1
		fi
	fi
fi

#readFile not supported (OS X 10.4 - 10.7), use sed
if [ "${readFileSupport}" = "false" ]; then
	#we must pass file contents in without empty lines so that readline can read all the input without truncation
	{ errOut=$( { { "${jsc}" -e "${JSCode}" -- "${queryArg}" "" "${options}" "${spaceArg}" "${valueArg}" "${pathArg}" "${depthArg}" "${encodingArg}" "${alterOp}" "${fromArg}" "${JSONPatchArg}" "${multiOutArg}" <<< "$(sed '/^$/d' "${fileArg:-/dev/stdin}")" ; } 1>&3 ; } 2>&1); } 3>&1
#file or file redirection
elif [ -f "${fileArg:=/dev/stdin}" ]; then
	{ errOut=$( { { "${jsc}" -e "${JSCode}" -- "${queryArg}" "${fileArg}" "${options}" "${spaceArg}" "${valueArg}" "${pathArg}" "${depthArg}" "${encodingArg}" "${alterOp}" "${fromArg}" "${JSONPatchArg}" "${multiOutArg}"; } 1>&3 ; } 2>&1); } 3>&1
	#direct out
	#"${jsc}" -e "${JSCode}" -- "${queryArg}" "${fileArg}" "${options}" "${spaceArg}" "${valueArg}" "${pathArg}" "${depthArg}" "${encodingArg}" "${alterOp}" "${fromArg}" "${JSONPatchArg}" "${multiOutArg}";
#pipe via cat
else
	#if file descriptor is 0 we do have no input
	[ -t '0' ] && echo -e "$(echo -e "${helpText}" | head -n 1)\nUsage: jpt [options] [query] [filepath] (see jpt -h for more help...)" >/dev/stderr && exit 0
	
	#just cat
	{ errOut=$( { { "${jsc}" -e "${JSCode}" -- "${queryArg}" "/dev/stdin" "${options}" "${spaceArg}" "${valueArg}" "${pathArg}" "${depthArg}" "${encodingArg}" "${alterOp}" "${fromArg}" "${JSONPatchArg}" "${multiOutArg}" <<< "$(cat)"; } 1>&3 ; } 2>&1); } 3>&1
fi

#if we have any output in errOut it came from stderr, strip Debug since we might use this for older jsc versions
#/bin/echo will not process whitespaces, this is how we like it
if [ -n "$(sed -e '/^--> Debug:/d' <<< "${errOut}")" ]; then /bin/echo "$errOut" >&2; return 1; fi
)

########
# MAIN #
########

#call the function and pass all arguments
jpt "$@"

exit $?
